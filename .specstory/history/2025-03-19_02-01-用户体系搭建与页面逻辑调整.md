<!-- Generated by SpecStory -->

# 用户体系搭建与页面逻辑调整 (2025-03-19 10:01:39)

_**User**_

我们现在需要基于对比前后端代码完成用户体系的搭建，包含组织架构，同时调整页面逻辑，没有登陆时直接显示登录页面，生成一个管理员账户，使用默认账户密码

---

_**Assistant**_



---

# 用户体系设计与实现方案

## 一、后端实现

### 1. 创建默认管理员账户

首先，我们需要在后端添加创建默认管理员账户的功能：

```python:backend/app/initial_setup.py
from sqlalchemy.orm import Session
from app.core.security import get_password_hash
from app.models.user import User
from app.models.organization import Organization
from app.core.config import settings

def create_default_admin(db: Session) -> None:
    """创建默认管理员账户和组织"""
    
    # 检查默认管理员是否已存在
    admin = db.query(User).filter(User.username == "admin").first()
    if not admin:
        # 创建默认组织
        default_org = Organization(
            name="默认组织",
            description="系统自动创建的默认组织"
        )
        db.add(default_org)
        db.flush()
        
        # 创建默认管理员账户
        admin_user = User(
            username="admin",
            email="admin@example.com",
            hashed_password=get_password_hash("admin123"),
            full_name="系统管理员",
            is_admin=True,
            is_active=True,
            organization_id=default_org.id
        )
        db.add(admin_user)
        db.commit()
        print("已创建默认管理员账户: admin/admin123")
```

### 2. 初始化数据库时调用

```python:backend/app/main.py
// ... existing code ...

from app.db.session import engine, SessionLocal
from app.initial_setup import create_default_admin

# 启动时执行的初始化函数
@app.on_event("startup")
def startup_event():
    db = SessionLocal()
    try:
        create_default_admin(db)
    finally:
        db.close()

// ... existing code ...
```

### 3. 添加组织模型

```python:backend/app/models/organization.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime
from sqlalchemy.sql import func

from app.db.base_class import Base

class Organization(Base):
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), index=True, nullable=False)
    description = Column(Text, nullable=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

### 4. 修改用户模型添加组织关联

```python:backend/app/models/user.py
// ... existing code ...
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

class User(Base):
    // ... existing code ...
    organization_id = Column(Integer, ForeignKey("organization.id"), nullable=True)
    organization = relationship("Organization", back_populates="users")
    is_admin = Column(Boolean, default=False)
    // ... existing code ...
```

## 二、前端实现

### 1. 创建路由守卫组件

```typescript:frontend/src/components/auth/ProtectedRoute.tsx
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';
import { Spin } from 'antd';
import { getToken } from '@/utils/auth';

type ProtectedRouteProps = {
  children: React.ReactNode;
};

const ProtectedRoute = ({ children }: ProtectedRouteProps) => {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const checkAuth = async () => {
      const token = getToken();
      
      // 如果没有token，重定向到登录页
      if (!token && router.pathname !== '/login') {
        router.replace('/login');
        return;
      }
      
      // 对已登录用户，如果访问登录页，重定向到主页
      if (token && router.pathname === '/login') {
        router.replace('/');
        return;
      }
      
      setIsLoading(false);
    };

    checkAuth();
  }, [router]);

  if (isLoading) {
    return (
      <div className="flex h-screen items-center justify-center">
        <Spin size="large" tip="加载中..." />
      </div>
    );
  }

  return <>{children}</>;
};

export default ProtectedRoute;
```

### 2. 创建认证工具函数

```typescript:frontend/src/utils/auth.ts
// Token相关的常量
const TOKEN_KEY = 'wk_access_token';

// 保存token
export const setToken = (token: string): void => {
  localStorage.setItem(TOKEN_KEY, token);
};

// 获取token
export const getToken = (): string | null => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem(TOKEN_KEY);
  }
  return null;
};

// 清除token
export const clearToken = (): void => {
  localStorage.removeItem(TOKEN_KEY);
};

// 判断是否已登录
export const isLoggedIn = (): boolean => {
  return !!getToken();
};
```

### 3. 在_app.tsx中应用路由守卫

```typescript:frontend/src/pages/_app.tsx
import type { AppProps } from 'next/app';
import { ConfigProvider } from 'antd';
import zhCN from 'antd/lib/locale/zh_CN';
import ProtectedRoute from '@/components/auth/ProtectedRoute';
import '@/styles/globals.css';

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <ConfigProvider locale={zhCN}>
      <ProtectedRoute>
        <Component {...pageProps} />
      </ProtectedRoute>
    </ConfigProvider>
  );
}

export default MyApp;
```

### 4. 修改登录表单组件以保存Token

```typescript:frontend/src/components/features/auth/LoginForm.tsx
import { useState } from 'react';
import { Form, Input, Button, message, Checkbox } from 'antd';
import { UserOutlined, LockOutlined } from '@ant-design/icons';
import { useRouter } from 'next/router';
import { setToken } from '@/utils/auth';

interface LoginFormData {
  username: string;
  password: string;
  remember: boolean;
}

const LoginForm = () => {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const onFinish = async (values: LoginFormData) => {
    setLoading(true);
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          username: values.username,
          password: values.password,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.detail || '登录失败');
      }

      // 保存token
      setToken(data.access_token);
      
      // 显示成功消息
      message.success('登录成功');
      
      // 跳转到首页
      router.push('/');
    } catch (error) {
      console.error('登录错误:', error);
      message.error(error instanceof Error ? error.message : '登录失败，请重试');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Form
      name="login"
      initialValues={{ remember: true }}
      onFinish={onFinish}
      size="large"
      layout="vertical"
    >
      <h1 className="text-2xl font-bold mb-6 text-center">账户登录</h1>
      
      <Form.Item
        name="username"
        rules={[{ required: true, message: '请输入用户名或邮箱' }]}
      >
        <Input 
          prefix={<UserOutlined className="site-form-item-icon" />} 
          placeholder="用户名或邮箱" 
        />
      </Form.Item>
      
      <Form.Item
        name="password"
        rules={[{ required: true, message: '请输入密码' }]}
      >
        <Input.Password 
          prefix={<LockOutlined className="site-form-item-icon" />}
          placeholder="密码" 
        />
      </Form.Item>
      
      <Form.Item>
        <Form.Item name="remember" valuePropName="checked" noStyle>
          <Checkbox>记住我</Checkbox>
        </Form.Item>
      </Form.Item>

      <Form.Item>
        <Button 
          type="primary" 
          htmlType="submit" 
          className="w-full" 
          loading={loading}
        >
          登录
        </Button>
      </Form.Item>
      
      <div className="text-center text-gray-500">
        <p>默认管理员账户: admin / admin123</p>
      </div>
    </Form>
  );
};

export default LoginForm;
```

## 三、组织架构管理页面

```typescript:frontend/src/pages/admin/organization/index.tsx
import { useState, useEffect } from 'react';
import { Table, Button, Space, Modal, Form, Input, message, Popconfirm } from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';

interface Organization {
  id: number;
  name: string;
  description: string;
  created_at: string;
}

const OrganizationManagement = () => {
  const [organizations, setOrganizations] = useState<Organization[]>([]);
  const [loading, setLoading] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [form] = Form.useForm();
  const [editingId, setEditingId] = useState<number | null>(null);

  // 获取组织列表
  const fetchOrganizations = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/admin/organizations');
      if (!response.ok) throw new Error('获取组织列表失败');
      const data = await response.json();
      setOrganizations(data);
    } catch (error) {
      message.error('获取组织列表失败');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchOrganizations();
  }, []);

  // 添加或更新组织
  const handleSubmit = async (values: any) => {
    try {
      const url = editingId 
        ? `/api/admin/organizations/${editingId}` 
        : '/api/admin/organizations';
      
      const method = editingId ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(values),
      });
      
      if (!response.ok) throw new Error('操作失败');
      
      message.success(editingId ? '更新成功' : '添加成功');
      setModalVisible(false);
      form.resetFields();
      setEditingId(null);
      fetchOrganizations();
    } catch (error) {
      message.error('操作失败');
      console.error(error);
    }
  };

  // 删除组织
  const handleDelete = async (id: number) => {
    try {
      const response = await fetch(`/api/admin/organizations/${id}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) throw new Error('删除失败');
      
      message.success('删除成功');
      fetchOrganizations();
    } catch (error) {
      message.error('删除失败');
      console.error(error);
    }
  };

  // 编辑组织
  const handleEdit = (record: Organization) => {
    setEditingId(record.id);
    form.setFieldsValue({
      name: record.name,
      description: record.description,
    });
    setModalVisible(true);
  };

  const columns = [
    {
      title: '组织名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: '描述',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: '创建时间',
      dataIndex: 'created_at',
      key: 'created_at',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: '操作',
      key: 'action',
      render: (_: any, record: Organization) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => handleEdit(record)}
          >
            编辑
          </Button>
          <Popconfirm
            title="确定要删除这个组织吗?"
            onConfirm={() => handleDelete(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="text" danger icon={<DeleteOutlined />}>
              删除
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <AdminLayout>
      <div className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-2xl font-bold">组织管理</h1>
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => {
              setEditingId(null);
              form.resetFields();
              setModalVisible(true);
            }}
          >
            添加组织
          </Button>
        </div>
        
        <Table 
          columns={columns} 
          dataSource={organizations} 
          rowKey="id"
          loading={loading}
          pagination={{ pageSize: 10 }}
        />
        
        <Modal
          title={editingId ? "编辑组织" : "添加组织"}
          open={modalVisible}
          onCancel={() => setModalVisible(false)}
          footer={null}
        >
          <Form
            form={form}
            layout="vertical"
            onFinish={handleSubmit}
          >
            <Form.Item
              name="name"
              label="组织名称"
              rules={[{ required: true, message: '请输入组织名称' }]}
            >
              <Input placeholder="请输入组织名称" />
            </Form.Item>
            
            <Form.Item
              name="description"
              label="描述"
            >
              <Input.TextArea rows={4} placeholder="请输入组织描述" />
            </Form.Item>
            
            <Form.Item className="mb-0 text-right">
              <Space>
                <Button onClick={() => setModalVisible(false)}>取消</Button>
                <Button type="primary" htmlType="submit">
                  {editingId ? '更新' : '添加'}
                </Button>
              </Space>
            </Form.Item>
          </Form>
        </Modal>
      </div>
    </AdminLayout>
  );
};

export default OrganizationManagement;
```

## 四、总结及下一步操作

通过以上代码，我们已经实现了：

1. 创建默认管理员账户 (admin/admin123)
2. 组织架构数据模型的设计
3. 登录逻辑的完善，包括Token存储和获取
4. 路由守卫实现，未登录状态下自动跳转到登录页
5. 组织架构管理页面

接下来需要：

1. 实现后端相应的组织管理API
2. 完善用户管理功能，包括用户的添加、编辑和删除
3. 添加用户权限控制逻辑
4. 完善管理员面板的其他功能

请根据项目需求适当调整以上代码。

---

_**User**_

管理员账户可以通过env文件配置

---

_**Assistant**_



---

# 通过环境变量配置管理员账户

## 后端实现

### 1. 修改配置文件添加环境变量

```python:backend/app/core/config.py
// ... existing code ...

class Settings(BaseSettings):
    // ... existing code ...
    
    # 默认管理员设置
    FIRST_ADMIN_USERNAME: str = "admin"
    FIRST_ADMIN_EMAIL: str = "admin@example.com"
    FIRST_ADMIN_PASSWORD: str = "admin123"
    FIRST_ADMIN_FULLNAME: str = "系统管理员"
    DEFAULT_ORG_NAME: str = "默认组织"
    
    // ... existing code ...

    class Config:
        env_file = ".env"
        case_sensitive = True

// ... existing code ...
```

### 2. 更新初始化脚本使用环境变量

```python:backend/app/initial_setup.py
from sqlalchemy.orm import Session
from app.core.security import get_password_hash
from app.models.user import User
from app.models.organization import Organization
from app.core.config import settings

def create_default_admin(db: Session) -> None:
    """创建默认管理员账户和组织"""
    
    # 检查默认管理员是否已存在
    admin = db.query(User).filter(User.username == settings.FIRST_ADMIN_USERNAME).first()
    if not admin:
        # 创建默认组织
        default_org = Organization(
            name=settings.DEFAULT_ORG_NAME,
            description="系统自动创建的默认组织"
        )
        db.add(default_org)
        db.flush()
        
        # 创建默认管理员账户
        admin_user = User(
            username=settings.FIRST_ADMIN_USERNAME,
            email=settings.FIRST_ADMIN_EMAIL,
            hashed_password=get_password_hash(settings.FIRST_ADMIN_PASSWORD),
            full_name=settings.FIRST_ADMIN_FULLNAME,
            is_admin=True,
            is_active=True,
            organization_id=default_org.id
        )
        db.add(admin_user)
        db.commit()
        print(f"已创建默认管理员账户: {settings.FIRST_ADMIN_USERNAME}/{settings.FIRST_ADMIN_PASSWORD}")
```

### 3. 创建示例环境变量文件

```env:backend/.env.example
# 数据库配置
DATABASE_URL=postgresql://postgres:password@localhost/weknowledge

# 安全配置
SECRET_KEY=your-secret-key-here
ACCESS_TOKEN_EXPIRE_MINUTES=1440  # 24小时

# 默认管理员设置
FIRST_ADMIN_USERNAME=admin
FIRST_ADMIN_EMAIL=admin@example.com
FIRST_ADMIN_PASSWORD=Secure123!
FIRST_ADMIN_FULLNAME=系统管理员
DEFAULT_ORG_NAME=默认组织
```

## 前端实现

### 修改登录表单提示信息

```typescript:frontend/src/components/features/auth/LoginForm.tsx
// ... existing code ...

const LoginForm = () => {
  // ... existing code ...

  return (
    <Form
      name="login"
      initialValues={{ remember: true }}
      onFinish={onFinish}
      size="large"
      layout="vertical"
    >
      <h1 className="text-2xl font-bold mb-6 text-center">账户登录</h1>
      
      <Form.Item
        name="username"
        rules={[{ required: true, message: '请输入用户名或邮箱' }]}
      >
        <Input 
          prefix={<UserOutlined className="site-form-item-icon" />} 
          placeholder="用户名或邮箱" 
        />
      </Form.Item>
      
      <Form.Item
        name="password"
        rules={[{ required: true, message: '请输入密码' }]}
      >
        <Input.Password 
          prefix={<LockOutlined className="site-form-item-icon" />}
          placeholder="密码" 
        />
      </Form.Item>
      
      <Form.Item>
        <Form.Item name="remember" valuePropName="checked" noStyle>
          <Checkbox>记住我</Checkbox>
        </Form.Item>
      </Form.Item>

      <Form.Item>
        <Button 
          type="primary" 
          htmlType="submit" 
          className="w-full" 
          loading={loading}
        >
          登录
        </Button>
      </Form.Item>
      
      <div className="text-center text-gray-500">
        <p>首次使用请使用管理员账户登录</p>
      </div>
    </Form>
  );
};

// ... existing code ...
```

## 部署准备

### 部署前设置环境变量

当您准备部署应用时，您需要:

1. 复制 `.env.example` 文件为 `.env`
2. 修改 `.env` 文件中的配置，特别是管理员凭据
3. 确保 `.env` 文件不会被提交到版本控制系统

```bash
# 复制示例环境变量文件
cp backend/.env.example backend/.env

# 编辑环境变量文件
nano backend/.env
```

通过使用环境变量配置管理员账户，您可以:

1. 在不同环境（开发、测试、生产）中使用不同的管理员凭据
2. 避免将默认密码硬编码到代码中，增强安全性
3. 在部署时方便地修改管理员信息

如果您使用Docker部署，还可以通过Docker环境变量或Docker Compose配置文件传递这些变量。

---

_**User**_

接下来需要：
实现后端相应的组织管理API
完善用户管理功能，包括用户的添加、编辑和删除
添加用户权限控制逻辑
完善管理员面板的其他功能

继续完成我们的开发

---

_**Assistant**_



---

# 继续完成系统开发计划

## 一、后端组织管理API实现

### 1. 组织管理API接口

```python:backend/app/api/api_v1/endpoints/organizations.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps

router = APIRouter()

@router.get("/", response_model=List[schemas.Organization])
def read_organizations(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取组织列表。
    """
    # 检查权限
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    organizations = crud.organization.get_multi(db, skip=skip, limit=limit)
    return organizations


@router.post("/", response_model=schemas.Organization)
def create_organization(
    *,
    db: Session = Depends(deps.get_db),
    organization_in: schemas.OrganizationCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新组织。
    """
    # 检查权限
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    organization = crud.organization.create(db=db, obj_in=organization_in)
    return organization


@router.get("/{id}", response_model=schemas.Organization)
def read_organization(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    根据ID获取组织信息。
    """
    organization = crud.organization.get(db=db, id=id)
    if not organization:
        raise HTTPException(status_code=404, detail="组织不存在")
    
    # 检查权限
    if not current_user.is_admin and current_user.organization_id != organization.id:
        raise HTTPException(status_code=403, detail="权限不足")
    
    return organization


@router.put("/{id}", response_model=schemas.Organization)
def update_organization(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    organization_in: schemas.OrganizationUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新组织信息。
    """
    organization = crud.organization.get(db=db, id=id)
    if not organization:
        raise HTTPException(status_code=404, detail="组织不存在")
    
    # 检查权限
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    organization = crud.organization.update(db=db, db_obj=organization, obj_in=organization_in)
    return organization


@router.delete("/{id}", response_model=schemas.Organization)
def delete_organization(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除组织。
    """
    organization = crud.organization.get(db=db, id=id)
    if not organization:
        raise HTTPException(status_code=404, detail="组织不存在")
    
    # 检查权限
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 检查是否有用户关联到该组织
    users = db.query(models.User).filter(models.User.organization_id == id).count()
    if users > 0:
        raise HTTPException(status_code=400, detail="该组织下存在用户，无法删除")
    
    organization = crud.organization.remove(db=db, id=id)
    return organization
```

### 2. 创建组织模型Schema

```python:backend/app/schemas/organization.py
from typing import Optional
from datetime import datetime
from pydantic import BaseModel

# 共享属性
class OrganizationBase(BaseModel):
    name: str
    description: Optional[str] = None
    is_active: Optional[bool] = True

# 创建时需要的属性
class OrganizationCreate(OrganizationBase):
    pass

# 更新时可以修改的属性
class OrganizationUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    is_active: Optional[bool] = None

# 数据库中完整的组织表示
class OrganizationInDBBase(OrganizationBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

# API中返回的组织表示
class Organization(OrganizationInDBBase):
    pass
```

### 3. 创建组织CRUD操作

```python:backend/app/crud/crud_organization.py
from typing import List, Optional, Dict, Union, Any

from fastapi.encoders import jsonable_encoder
from sqlalchemy.orm import Session

from app.crud.base import CRUDBase
from app.models.organization import Organization
from app.schemas.organization import OrganizationCreate, OrganizationUpdate

class CRUDOrganization(CRUDBase[Organization, OrganizationCreate, OrganizationUpdate]):
    def create_with_owner(
        self, db: Session, *, obj_in: OrganizationCreate, owner_id: int
    ) -> Organization:
        obj_in_data = jsonable_encoder(obj_in)
        db_obj = self.model(**obj_in_data)
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def get_by_name(self, db: Session, *, name: str) -> Optional[Organization]:
        return db.query(self.model).filter(self.model.name == name).first()

organization = CRUDOrganization(Organization)
```

### 4. 用户管理API接口

```python:backend/app/api/api_v1/endpoints/users.py
from typing import Any, List, Optional

from fastapi import APIRouter, Body, Depends, HTTPException, Query
from fastapi.encoders import jsonable_encoder
from pydantic import EmailStr
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps
from app.core.config import settings

router = APIRouter()

@router.get("/", response_model=List[schemas.User])
def read_users(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    organization_id: Optional[int] = None,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取用户列表。
    """
    # 管理员可以查看所有用户，普通用户只能看自己组织的用户
    if current_user.is_admin:
        if organization_id:
            users = crud.user.get_by_organization(
                db, organization_id=organization_id, skip=skip, limit=limit
            )
        else:
            users = crud.user.get_multi(db, skip=skip, limit=limit)
    else:
        users = crud.user.get_by_organization(
            db, organization_id=current_user.organization_id, skip=skip, limit=limit
        )
    
    return users


@router.post("/", response_model=schemas.User)
def create_user(
    *,
    db: Session = Depends(deps.get_db),
    user_in: schemas.UserCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新用户。
    """
    # 验证权限
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 检查用户名是否已存在
    user = crud.user.get_by_username(db, username=user_in.username)
    if user:
        raise HTTPException(
            status_code=400,
            detail="该用户名已被注册",
        )
    
    # 检查邮箱是否已存在
    user = crud.user.get_by_email(db, email=user_in.email)
    if user:
        raise HTTPException(
            status_code=400,
            detail="该邮箱已被注册",
        )
    
    # 检查组织是否存在
    if user_in.organization_id:
        organization = crud.organization.get(db, id=user_in.organization_id)
        if not organization:
            raise HTTPException(
                status_code=404,
                detail="指定的组织不存在",
            )
    
    user = crud.user.create(db, obj_in=user_in)
    return user


@router.put("/me", response_model=schemas.User)
def update_user_me(
    *,
    db: Session = Depends(deps.get_db),
    full_name: Optional[str] = Body(None),
    email: Optional[EmailStr] = Body(None),
    password: Optional[str] = Body(None),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新当前用户信息。
    """
    current_user_data = jsonable_encoder(current_user)
    user_in = schemas.UserUpdate(**current_user_data)
    if full_name is not None:
        user_in.full_name = full_name
    if email is not None:
        user_in.email = email
    if password is not None:
        user_in.password = password
    
    user = crud.user.update(db, db_obj=current_user, obj_in=user_in)
    return user


@router.get("/me", response_model=schemas.User)
def read_user_me(
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取当前用户信息。
    """
    return current_user


@router.get("/{user_id}", response_model=schemas.User)
def read_user_by_id(
    user_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
    db: Session = Depends(deps.get_db),
) -> Any:
    """
    根据ID获取用户信息。
    """
    user = crud.user.get(db, id=user_id)
    if not user:
        raise HTTPException(
            status_code=404,
            detail="用户不存在",
        )
    
    # 管理员可以查看任何用户，普通用户只能查看自己组织的用户
    if not current_user.is_admin and (user.organization_id != current_user.organization_id):
        raise HTTPException(
            status_code=403,
            detail="权限不足",
        )
    
    return user


@router.put("/{user_id}", response_model=schemas.User)
def update_user(
    *,
    db: Session = Depends(deps.get_db),
    user_id: int,
    user_in: schemas.UserUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新用户信息。
    """
    user = crud.user.get(db, id=user_id)
    if not user:
        raise HTTPException(
            status_code=404,
            detail="用户不存在",
        )
    
    # 管理员可以更新任何用户，普通用户只能更新自己
    if not current_user.is_admin and current_user.id != user_id:
        raise HTTPException(
            status_code=403,
            detail="权限不足",
        )
    
    # 普通用户不能修改自己的组织和管理员状态
    if not current_user.is_admin:
        if hasattr(user_in, "is_admin") and user_in.is_admin is not None:
            raise HTTPException(
                status_code=403,
                detail="无权修改管理员状态",
            )
        if hasattr(user_in, "organization_id") and user_in.organization_id is not None:
            raise HTTPException(
                status_code=403,
                detail="无权修改所属组织",
            )
    
    user = crud.user.update(db, db_obj=user, obj_in=user_in)
    return user


@router.delete("/{user_id}", response_model=schemas.User)
def delete_user(
    *,
    db: Session = Depends(deps.get_db),
    user_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除用户。
    """
    # 只有管理员可以删除用户
    if not current_user.is_admin:
        raise HTTPException(
            status_code=403,
            detail="权限不足",
        )
    
    user = crud.user.get(db, id=user_id)
    if not user:
        raise HTTPException(
            status_code=404,
            detail="用户不存在",
        )
    
    # 不能删除自己
    if user.id == current_user.id:
        raise HTTPException(
            status_code=400,
            detail="不能删除自己的账户",
        )
    
    user = crud.user.remove(db, id=user_id)
    return user
```

### 5. 修改用户模型Schema

```python:backend/app/schemas/user.py
from typing import Optional, List
from pydantic import BaseModel, EmailStr
from datetime import datetime

# 共享属性
class UserBase(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    is_active: Optional[bool] = True
    full_name: Optional[str] = None
    is_admin: bool = False
    organization_id: Optional[int] = None

# 创建用户需要的属性
class UserCreate(UserBase):
    email: EmailStr
    username: str
    password: str
    organization_id: int

# 更新用户可修改的属性
class UserUpdate(UserBase):
    password: Optional[str] = None

# 数据库中存储的用户信息
class UserInDBBase(UserBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

# API返回的用户信息
class User(UserInDBBase):
    pass

# 数据库中存储的用户信息（包含哈希后的密码）
class UserInDB(UserInDBBase):
    hashed_password: str
```

### 6. 更新用户CRUD操作

```python:backend/app/crud/crud_user.py
from typing import Any, Dict, Optional, Union, List

from sqlalchemy.orm import Session

from app.core.security import get_password_hash, verify_password
from app.crud.base import CRUDBase
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate


class CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):
    def get_by_email(self, db: Session, *, email: str) -> Optional[User]:
        return db.query(User).filter(User.email == email).first()

    def get_by_username(self, db: Session, *, username: str) -> Optional[User]:
        return db.query(User).filter(User.username == username).first()

    def get_by_organization(
        self, db: Session, *, organization_id: int, skip: int = 0, limit: int = 100
    ) -> List[User]:
        return (
            db.query(User)
            .filter(User.organization_id == organization_id)
            .offset(skip)
            .limit(limit)
            .all()
        )

    def create(self, db: Session, *, obj_in: UserCreate) -> User:
        db_obj = User(
            email=obj_in.email,
            username=obj_in.username,
            hashed_password=get_password_hash(obj_in.password),
            full_name=obj_in.full_name,
            is_admin=obj_in.is_admin,
            is_active=obj_in.is_active,
            organization_id=obj_in.organization_id,
        )
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def update(
        self, db: Session, *, db_obj: User, obj_in: Union[UserUpdate, Dict[str, Any]]
    ) -> User:
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.dict(exclude_unset=True)
        if update_data.get("password"):
            hashed_password = get_password_hash(update_data["password"])
            del update_data["password"]
            update_data["hashed_password"] = hashed_password
        return super().update(db, db_obj=db_obj, obj_in=update_data)

    def authenticate(self, db: Session, *, username: str, password: str) -> Optional[User]:
        user = self.get_by_username(db, username=username)
        if not user:
            user = self.get_by_email(db, email=username)
        if not user:
            return None
        if not verify_password(password, user.hashed_password):
            return None
        return user

    def is_active(self, user: User) -> bool:
        return user.is_active

    def is_admin(self, user: User) -> bool:
        return user.is_admin


user = CRUDUser(User)
```

### 7. 注册API路由

```python:backend/app/api/api_v1/api.py
from fastapi import APIRouter

from app.api.api_v1.endpoints import auth, users, organizations

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["认证"])
api_router.include_router(users.router, prefix="/users", tags=["用户"])
api_router.include_router(organizations.router, prefix="/organizations", tags=["组织"])
```

## 二、前端管理界面实现

### 1. 用户管理页面

```typescript:frontend/src/pages/admin/organization/users.tsx
import { useState, useEffect } from 'react';
import { Table, Button, Space, Modal, Form, Input, Select, message, Popconfirm, Switch } from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined, UserOutlined, MailOutlined, LockOutlined } from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

interface User {
  id: number;
  username: string;
  email: string;
  full_name: string;
  is_admin: boolean;
  is_active: boolean;
  organization_id: number;
  created_at: string;
}

interface Organization {
  id: number;
  name: string;
}

const UserManagement = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [organizations, setOrganizations] = useState<Organization[]>([]);
  const [loading, setLoading] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [form] = Form.useForm();
  const [editingId, setEditingId] = useState<number | null>(null);

  // 获取用户列表
  const fetchUsers = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/users', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      if (!response.ok) throw new Error('获取用户列表失败');
      const data = await response.json();
      setUsers(data);
    } catch (error) {
      message.error('获取用户列表失败');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  // 获取组织列表
  const fetchOrganizations = async () => {
    try {
      const response = await fetch('/api/organizations', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      if (!response.ok) throw new Error('获取组织列表失败');
      const data = await response.json();
      setOrganizations(data);
    } catch (error) {
      message.error('获取组织列表失败');
      console.error(error);
    }
  };

  useEffect(() => {
    fetchUsers();
    fetchOrganizations();
  }, []);

  // 添加或更新用户
  const handleSubmit = async (values: any) => {
    try {
      const url = editingId 
        ? `/api/users/${editingId}` 
        : '/api/users';
      
      const method = editingId ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || '操作失败');
      }
      
      message.success(editingId ? '更新成功' : '添加成功');
      setModalVisible(false);
      form.resetFields();
      setEditingId(null);
      fetchUsers();
    } catch (error) {
      message.error(error instanceof Error ? error.message : '操作失败');
      console.error(error);
    }
  };

  // 删除用户
  const handleDelete = async (id: number) => {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || '删除失败');
      }
      
      message.success('删除成功');
      fetchUsers();
    } catch (error) {
      message.error(error instanceof Error ? error.message : '删除失败');
      console.error(error);
    }
  };

  // 编辑用户
  const handleEdit = (record: User) => {
    setEditingId(record.id);
    form.setFieldsValue({
      username: record.username,
      email: record.email,
      full_name: record.full_name,
      is_admin: record.is_admin,
      is_active: record.is_active,
      organization_id: record.organization_id,
    });
    setModalVisible(true);
  };

  const columns = [
    {
      title: '用户名',
      dataIndex: 'username',
      key: 'username',
    },
    {
      title: '邮箱',
      dataIndex: 'email',
      key: 'email',
    },
    {
      title: '姓名',
      dataIndex: 'full_name',
      key: 'full_name',
    },
    {
      title: '组织',
      dataIndex: 'organization_id',
      key: 'organization_id',
      render: (org_id: number) => {
        const org = organizations.find(o => o.id === org_id);
        return org ? org.name : '-';
      }
    },
    {
      title: '管理员',
      dataIndex: 'is_admin',
      key: 'is_admin',
      render: (is_admin: boolean) => is_admin ? '是' : '否',
    },
    {
      title: '状态',
      dataIndex: 'is_active',
      key: 'is_active',
      render: (is_active: boolean) => is_active ? '激活' : '禁用',
    },
    {
      title: '创建时间',
      dataIndex: 'created_at',
      key: 'created_at',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: '操作',
      key: 'action',
      render: (_: any, record: User) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => handleEdit(record)}
          >
            编辑
          </Button>
          <Popconfirm
            title="确定要删除这个用户吗?"
            onConfirm={() => handleDelete(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="text" danger icon={<DeleteOutlined />}>
              删除
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <AdminLayout>
      <div className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-2xl font-bold">用户管理</h1>
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => {
              setEditingId(null);
              form.resetFields();
              setModalVisible(true);
            }}
          >
            添加用户
          </Button>
        </div>
        
        <Table 
          columns={columns} 
          dataSource={users} 
          rowKey="id"
          loading={loading}
          pagination={{ pageSize: 10 }}
        />
        
        <Modal
          title={editingId ? "编辑用户" : "添加用户"}
          open={modalVisible}
          onCancel={() => setModalVisible(false)}
          footer={null}
        >
          <Form
            form={form}
            layout="vertical"
            onFinish={handleSubmit}
          >
            <Form.Item
              name="username"
              label="用户名"
              rules={[{ required: true, message: '请输入用户名' }]}
            >
              <Input 
                prefix={<UserOutlined />} 
                placeholder="请输入用户名" 
                disabled={!!editingId} // 编辑模式下禁止修改用户名
              />
            </Form.Item>
            
            <Form.Item
              name="email"
              label="邮箱"
              rules={[
                { required: true, message: '请输入邮箱' },
                { type: 'email', message: '请输入有效的邮箱地址' }
              ]}
            >
              <Input prefix={<MailOutlined />} placeholder="请输入邮箱" />
            </Form.Item>
            
            {!editingId && (
              <Form.Item
                name="password"
                label="密码"
                rules={[{ required: true, message: '请输入密码' }]}
              >
                <Input.Password prefix={<LockOutlined />} placeholder="请输入密码" />
              </Form.Item>
            )}
            
            <Form.Item
              name="full_name"
              label="姓名"
            >
              <Input placeholder="请输入姓名" />
            </Form.Item>
            
            <Form.Item
              name="organization_id"
              label="所属组织"
              rules={[{ required: true, message: '请选择所属组织' }]}
            >
              <Select placeholder="请选择所属组织">
                {organizations.map(org => (
                  <Select.Option key={org.id} value={org.id}>{org.name}</Select.Option>
                ))}
              </Select>
            </Form.Item>
            
            <Form.Item
              name="is_admin"
              label="管理员权限"
              valuePropName="checked"
            >
              <Switch />
            </Form.Item>
            
            <Form.Item
              name="is_active"
              label="激活状态"
              valuePropName="checked"
              initialValue={true}
            >
              <Switch />
            </Form.Item>
            
            <Form.Item className="mb-0 text-right">
              <Space>
                <Button onClick={() => setModalVisible(false)}>取消</Button>
                <Button type="primary" htmlType="submit">
                  {editingId ? '更新' : '添加'}
                </Button>
              </Space>
            </Form.Item>
          </Form>
        </Modal>
      </div>
    </AdminLayout>
  );
};

export default UserManagement;
```

### 2. 创建管理员布局组件

```typescript:frontend/src/components/layouts/AdminLayout.tsx
import React, { useState, useEffect } from 'react';
import { Layout, Menu, Button, Dropdown, Avatar, Breadcrumb } from 'antd';
import { 
  MenuFoldOutlined, 
  MenuUnfoldOutlined, 
  UserOutlined, 
  DashboardOutlined,
  TeamOutlined,
  SettingOutlined,
  LogoutOutlined,
  BuildOutlined
} from '@ant-design/icons';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { clearToken } from '@/utils/auth';

const { Header, Sider, Content } = Layout;

interface AdminLayoutProps {
  children: React.ReactNode;
}

const AdminLayout: React.FC<AdminLayoutProps> = ({ children }) => {
  const [collapsed, setCollapsed] = useState(false);
  const [username, setUsername] = useState('');
  const router = useRouter();

  useEffect(() => {
    // 获取当前用户信息
    const fetchUserInfo = async () => {
      try {
        const response = await fetch('/api/users/me');
        if (response.ok) {
          const user = await response.json();
          setUsername(user.username);
        }
      } catch (error) {
        console.error('获取用户信息失败', error);
      }
    };

    fetchUserInfo();
  }, []);

  const handleLogout = () => {
    clearToken();
    router.push('/login');
  };

  // 确定当前活动菜单项
  const getSelectedKeys = () => {
    const path = router.pathname;
    if (path.startsWith('/admin/dashboard')) return ['dashboard'];
    if (path.startsWith('/admin/organization/users')) return ['users'];
    if (path.startsWith('/admin/organization')) return ['organizations'];
    if (path.startsWith('/admin/knowledge-config')) return ['knowledge-config'];
    if (path.startsWith('/admin/settings')) return ['settings'];
    return [];
  };

  // 生成面包屑
  const getBreadcrumbItems = () => {
    const items = [{ title: '管理后台', href: '/admin/dashboard' }];
    const path = router.pathname;
    
    if (path.includes('/dashboard')) {
      items.push({ title: '仪表盘', href: '/admin/dashboard' });
    } else if (path.includes('/organization/users')) {
      items.push({ title: '组织管理', href: '/admin/organization' });
      items.push({ title: '用户管理', href: '/admin/organization/users' });
    } else if (path.includes('/organization')) {
      items.push({ title: '组织管理', href: '/admin/organization' });
    } else if (path.includes('/knowledge-config')) {
      items.push({ title: '知识库配置', href: '/admin/knowledge-config' });
    } else if (path.includes('/settings')) {
      items.push({ title: '系统设置', href: '/admin/settings' });
    }
    
    return items;
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider 
        trigger={null} 
        collapsible 
        collapsed={collapsed}
        width={250}
        theme="dark"
      >
        <div className="p-4 h-16 flex items-center">
          <div className="text-white text-lg font-bold truncate">
            {!collapsed && '企业智能知识库平台'}
            {collapsed && 'WK'}
          </div>
        </div>
        <Menu
          theme="dark"
          mode="inline"
          selectedKeys={getSelectedKeys()}
          items={[
            {
              key: 'dashboard',
              icon: <DashboardOutlined />,
              label: <Link href="/admin/dashboard">仪表盘</Link>,
            },
            {
              key: 'organizations',
              icon: <TeamOutlined />,
              label: <Link href="/admin/organization">组织管理</Link>,
            },
            {
              key: 'users',
              icon: <UserOutlined />,
              label: <Link href="/admin/organization/users">用户管理</Link>,
            },
            {
              key: 'knowledge-config',
              icon: <BuildOutlined />,
              label: <Link href="/admin/knowledge-config">知识库配置</Link>,
            },
            {
              key: 'settings',
              icon: <SettingOutlined />,
              label: <Link href="/admin/settings">系统设置</Link>,
            },
          ]}
        />
      </Sider>
      <Layout>
        <Header className="bg-white p-0 px-4 flex justify-between items-center shadow-sm">
          <Button
            type="text"
            icon={collapsed ? <MenuUnfoldOutlined /> : <MenuFoldOutlined />}
            onClick={() => setCollapsed(!collapsed)}
            className="text-lg"
          />
          <Dropdown menu={{
            items: [
              { key: 'profile', label: '个人信息', icon: <UserOutlined /> },
              { key: 'logout', label: '退出登录', icon: <LogoutOutlined />, onClick: handleLogout }
            ]
          }}>
            <div className="flex items-center cursor-pointer">
              <Avatar icon={<UserOutlined />} className="mr-2" />
              <span>{username}</span>
            </div>
          </Dropdown>
        </Header>
        <div className="bg-gray-50 px-6 py-2">
          <Breadcrumb>
            {getBreadcrumbItems().map((item, index) => (
              <Breadcrumb.Item key={index}>
                {item.href ? <Link href={item.href}>{item.title}</Link> : item.title}
              </Breadcrumb.Item>
            ))}
          </Breadcrumb>
        </div>
        <Content className="m-4 p-4 bg-white rounded">
          {children}
        </Content>
      </Layout>
    </Layout>
  );
};

export default AdminLayout;
```

### 3. 创建管理员仪表盘

```typescript:frontend/src/pages/admin/dashboard/index.tsx
import { useState, useEffect } from 'react';
import { Row, Col, Card, Statistic } from 'antd';
import {
  UserOutlined,
  TeamOutlined,
  FileOutlined,
  QuestionOutlined
} from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

interface DashboardStats {
  userCount: number;
  organizationCount: number;
  knowledgeBaseCount: number;
  totalQueries: number;
}

const Dashboard = () => {
  const [stats, setStats] = useState<DashboardStats>({
    userCount: 0,
    organizationCount: 0,
    knowledgeBaseCount: 0,
    totalQueries: 0
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDashboardStats = async () => {
      setLoading(true);
      try {
        // 这里假设有一个API接口返回仪表盘数据
        // 实际开发时需要实现对应的后端接口
        const response = await fetch('/api/admin/dashboard/stats', {
          headers: {
            'Authorization': `Bearer ${getToken()}`
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          setStats(data);
        } else {
          // 如果接口不存在，使用模拟数据
          setStats({
            userCount: 5,
            organizationCount

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统开发计划

## 前端管理界面实现(续)

### 3. 管理员仪表盘(续)

```typescript:frontend/src/pages/admin/dashboard/index.tsx
import { useState, useEffect } from 'react';
import { Row, Col, Card, Statistic } from 'antd';
import {
  UserOutlined,
  TeamOutlined,
  FileOutlined,
  QuestionOutlined
} from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

interface DashboardStats {
  userCount: number;
  organizationCount: number;
  knowledgeBaseCount: number;
  totalQueries: number;
}

const Dashboard = () => {
  const [stats, setStats] = useState<DashboardStats>({
    userCount: 0,
    organizationCount: 0,
    knowledgeBaseCount: 0,
    totalQueries: 0
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDashboardStats = async () => {
      setLoading(true);
      try {
        // 这里假设有一个API接口返回仪表盘数据
        // 实际开发时需要实现对应的后端接口
        const response = await fetch('/api/admin/dashboard/stats', {
          headers: {
            'Authorization': `Bearer ${getToken()}`
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          setStats(data);
        } else {
          // 如果接口不存在，使用模拟数据
          setStats({
            userCount: 5,
            organizationCount: 2,
            knowledgeBaseCount: 3,
            totalQueries: 120
          });
        }
      } catch (error) {
        console.error('获取仪表盘数据失败', error);
        // 发生错误时使用模拟数据
        setStats({
          userCount: 5,
          organizationCount: 2,
          knowledgeBaseCount: 3,
          totalQueries: 120
        });
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardStats();
  }, []);

  return (
    <AdminLayout>
      <div className="p-4">
        <h1 className="text-2xl font-bold mb-6">系统概览</h1>
        
        <Row gutter={[16, 16]}>
          <Col xs={24} sm={12} md={6}>
            <Card loading={loading}>
              <Statistic
                title="用户数量"
                value={stats.userCount}
                prefix={<UserOutlined />}
              />
            </Card>
          </Col>
          
          <Col xs={24} sm={12} md={6}>
            <Card loading={loading}>
              <Statistic
                title="组织数量"
                value={stats.organizationCount}
                prefix={<TeamOutlined />}
              />
            </Card>
          </Col>
          
          <Col xs={24} sm={12} md={6}>
            <Card loading={loading}>
              <Statistic
                title="知识库数量"
                value={stats.knowledgeBaseCount}
                prefix={<FileOutlined />}
              />
            </Card>
          </Col>
          
          <Col xs={24} sm={12} md={6}>
            <Card loading={loading}>
              <Statistic
                title="总查询次数"
                value={stats.totalQueries}
                prefix={<QuestionOutlined />}
              />
            </Card>
          </Col>
        </Row>
        
        <div className="mt-8">
          <h2 className="text-xl font-bold mb-4">系统信息</h2>
          <Card>
            <p><strong>系统名称：</strong>企业智能知识库平台</p>
            <p><strong>版本号：</strong>1.0.0</p>
            <p><strong>运行状态：</strong>正常</p>
            <p><strong>上次更新：</strong>{new Date().toLocaleDateString()}</p>
          </Card>
        </div>
        
        <div className="mt-8">
          <h2 className="text-xl font-bold mb-4">快速操作</h2>
          <Row gutter={[16, 16]}>
            <Col xs={24} sm={12} md={8}>
              <Card
                title="用户管理"
                extra={<a href="/admin/organization/users">进入</a>}
              >
                管理系统用户，创建、编辑或删除用户账户
              </Card>
            </Col>
            
            <Col xs={24} sm={12} md={8}>
              <Card
                title="组织管理"
                extra={<a href="/admin/organization">进入</a>}
              >
                管理组织架构，创建和配置组织
              </Card>
            </Col>
            
            <Col xs={24} sm={12} md={8}>
              <Card
                title="知识库配置"
                extra={<a href="/admin/knowledge-config">进入</a>}
              >
                配置和管理知识库数据源和设置
              </Card>
            </Col>
          </Row>
        </div>
      </div>
    </AdminLayout>
  );
};

export default Dashboard;
```

### 4. 知识库配置页面

```typescript:frontend/src/pages/admin/knowledge-config/index.tsx
import { useState, useEffect } from 'react';
import { Tabs, Card, Form, Input, Button, Select, Switch, message, Table, Space, Popconfirm } from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

const { TabPane } = Tabs;

interface DataSource {
  id: number;
  name: string;
  type: string;
  connection_url: string;
  is_active: boolean;
  created_at: string;
}

interface LLMConfig {
  id: number;
  name: string;
  api_key: string;
  model: string;
  temperature: number;
  is_default: boolean;
}

const KnowledgeConfig = () => {
  const [dataSources, setDataSources] = useState<DataSource[]>([]);
  const [llmConfigs, setLlmConfigs] = useState<LLMConfig[]>([]);
  const [dataSourceForm] = Form.useForm();
  const [llmForm] = Form.useForm();
  const [loading, setLoading] = useState(false);
  const [activeTab, setActiveTab] = useState('1');

  // 获取数据源列表
  const fetchDataSources = async () => {
    setLoading(true);
    try {
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/knowledge-config/data-sources', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setDataSources(data);
      } else {
        // 如果API未实现，使用模拟数据
        setDataSources([
          {
            id: 1,
            name: '示例PostgreSQL数据库',
            type: 'postgresql',
            connection_url: 'postgresql://user:password@localhost:5432/db',
            is_active: true,
            created_at: new Date().toISOString()
          }
        ]);
      }
    } catch (error) {
      console.error('获取数据源列表失败', error);
      message.error('获取数据源列表失败');
    } finally {
      setLoading(false);
    }
  };

  // 获取LLM配置列表
  const fetchLlmConfigs = async () => {
    setLoading(true);
    try {
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/knowledge-config/llm-configs', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setLlmConfigs(data);
      } else {
        // 如果API未实现，使用模拟数据
        setLlmConfigs([
          {
            id: 1,
            name: 'GPT-4配置',
            api_key: '****',
            model: 'gpt-4',
            temperature: 0.7,
            is_default: true
          }
        ]);
      }
    } catch (error) {
      console.error('获取LLM配置列表失败', error);
      message.error('获取LLM配置列表失败');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (activeTab === '1') {
      fetchDataSources();
    } else if (activeTab === '2') {
      fetchLlmConfigs();
    }
  }, [activeTab]);

  // 数据源表格列定义
  const dataSourceColumns = [
    {
      title: '名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: '类型',
      dataIndex: 'type',
      key: 'type',
      render: (type: string) => {
        const typeMap: Record<string, string> = {
          'postgresql': 'PostgreSQL',
          'mysql': 'MySQL',
          'file': '文件系统',
          'elastic': 'Elasticsearch'
        };
        return typeMap[type] || type;
      },
    },
    {
      title: '连接URL',
      dataIndex: 'connection_url',
      key: 'connection_url',
      render: (url: string) => {
        // 简单处理，隐藏敏感信息
        return url.replace(/(password=)[^&]+/, '$1****');
      },
    },
    {
      title: '状态',
      dataIndex: 'is_active',
      key: 'is_active',
      render: (active: boolean) => active ? '启用' : '禁用',
    },
    {
      title: '操作',
      key: 'action',
      render: (_: any, record: DataSource) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => handleEditDataSource(record)}
          >
            编辑
          </Button>
          <Popconfirm
            title="确定要删除这个数据源吗?"
            onConfirm={() => handleDeleteDataSource(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="text" danger icon={<DeleteOutlined />}>
              删除
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  // LLM配置表格列定义
  const llmConfigColumns = [
    {
      title: '名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: 'API Key',
      dataIndex: 'api_key',
      key: 'api_key',
      render: () => '********',
    },
    {
      title: '模型',
      dataIndex: 'model',
      key: 'model',
    },
    {
      title: '温度',
      dataIndex: 'temperature',
      key: 'temperature',
    },
    {
      title: '默认',
      dataIndex: 'is_default',
      key: 'is_default',
      render: (isDefault: boolean) => isDefault ? '是' : '否',
    },
    {
      title: '操作',
      key: 'action',
      render: (_: any, record: LLMConfig) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => handleEditLlmConfig(record)}
          >
            编辑
          </Button>
          <Popconfirm
            title="确定要删除这个配置吗?"
            onConfirm={() => handleDeleteLlmConfig(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="text" danger icon={<DeleteOutlined />}>
              删除
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  // 编辑数据源
  const handleEditDataSource = (record: DataSource) => {
    dataSourceForm.setFieldsValue(record);
  };

  // 删除数据源
  const handleDeleteDataSource = async (id: number) => {
    try {
      // 实际项目中需要实现后端API
      const response = await fetch(`/api/admin/knowledge-config/data-sources/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        message.success('数据源删除成功');
        fetchDataSources();
      } else {
        throw new Error('删除失败');
      }
    } catch (error) {
      console.error('删除数据源失败', error);
      message.error('删除数据源失败');
    }
  };

  // 编辑LLM配置
  const handleEditLlmConfig = (record: LLMConfig) => {
    llmForm.setFieldsValue(record);
  };

  // 删除LLM配置
  const handleDeleteLlmConfig = async (id: number) => {
    try {
      // 实际项目中需要实现后端API
      const response = await fetch(`/api/admin/knowledge-config/llm-configs/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        message.success('配置删除成功');
        fetchLlmConfigs();
      } else {
        throw new Error('删除失败');
      }
    } catch (error) {
      console.error('删除LLM配置失败', error);
      message.error('删除LLM配置失败');
    }
  };

  // 保存数据源
  const handleSaveDataSource = async (values: any) => {
    try {
      // 实际项目中需要实现后端API
      const url = values.id 
        ? `/api/admin/knowledge-config/data-sources/${values.id}` 
        : '/api/admin/knowledge-config/data-sources';
      
      const method = values.id ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (response.ok) {
        message.success(values.id ? '数据源更新成功' : '数据源创建成功');
        dataSourceForm.resetFields();
        fetchDataSources();
      } else {
        throw new Error('保存失败');
      }
    } catch (error) {
      console.error('保存数据源失败', error);
      message.error('保存数据源失败');
    }
  };

  // 保存LLM配置
  const handleSaveLlmConfig = async (values: any) => {
    try {
      // 实际项目中需要实现后端API
      const url = values.id 
        ? `/api/admin/knowledge-config/llm-configs/${values.id}` 
        : '/api/admin/knowledge-config/llm-configs';
      
      const method = values.id ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (response.ok) {
        message.success(values.id ? 'LLM配置更新成功' : 'LLM配置创建成功');
        llmForm.resetFields();
        fetchLlmConfigs();
      } else {
        throw new Error('保存失败');
      }
    } catch (error) {
      console.error('保存LLM配置失败', error);
      message.error('保存LLM配置失败');
    }
  };

  return (
    <AdminLayout>
      <div className="p-4">
        <h1 className="text-2xl font-bold mb-6">知识库配置</h1>
        
        <Tabs 
          activeKey={activeTab} 
          onChange={setActiveTab}
        >
          <TabPane tab="数据源配置" key="1">
            <div className="flex space-x-4">
              <div className="w-1/3">
                <Card title="数据源详情">
                  <Form
                    form={dataSourceForm}
                    layout="vertical"
                    onFinish={handleSaveDataSource}
                  >
                    <Form.Item
                      name="id"
                      hidden
                    >
                      <Input />
                    </Form.Item>
                    
                    <Form.Item
                      name="name"
                      label="数据源名称"
                      rules={[{ required: true, message: '请输入数据源名称' }]}
                    >
                      <Input placeholder="请输入数据源名称" />
                    </Form.Item>
                    
                    <Form.Item
                      name="type"
                      label="数据源类型"
                      rules={[{ required: true, message: '请选择数据源类型' }]}
                    >
                      <Select placeholder="请选择数据源类型">
                        <Select.Option value="postgresql">PostgreSQL</Select.Option>
                        <Select.Option value="mysql">MySQL</Select.Option>
                        <Select.Option value="file">文件系统</Select.Option>
                        <Select.Option value="elastic">Elasticsearch</Select.Option>
                      </Select>
                    </Form.Item>
                    
                    <Form.Item
                      name="connection_url"
                      label="连接URL"
                      rules={[{ required: true, message: '请输入连接URL' }]}
                    >
                      <Input.TextArea 
                        placeholder="请输入连接URL" 
                        rows={3}
                      />
                    </Form.Item>
                    
                    <Form.Item
                      name="is_active"
                      label="状态"
                      valuePropName="checked"
                      initialValue={true}
                    >
                      <Switch checkedChildren="启用" unCheckedChildren="禁用" />
                    </Form.Item>
                    
                    <Form.Item>
                      <Button 
                        type="primary" 
                        htmlType="submit"
                        block
                      >
                        保存
                      </Button>
                    </Form.Item>
                    
                    <Form.Item>
                      <Button 
                        htmlType="button"
                        block
                        onClick={() => dataSourceForm.resetFields()}
                      >
                        重置
                      </Button>
                    </Form.Item>
                  </Form>
                </Card>
              </div>
              
              <div className="w-2/3">
                <Card 
                  title="数据源列表" 
                  extra={
                    <Button 
                      type="primary" 
                      icon={<PlusOutlined />}
                      onClick={() => {
                        dataSourceForm.resetFields();
                      }}
                    >
                      新建
                    </Button>
                  }
                >
                  <Table
                    columns={dataSourceColumns}
                    dataSource={dataSources}
                    rowKey="id"
                    loading={loading && activeTab === '1'}
                    pagination={{ pageSize: 5 }}
                  />
                </Card>
              </div>
            </div>
          </TabPane>
          
          <TabPane tab="LLM模型配置" key="2">
            <div className="flex space-x-4">
              <div className="w-1/3">
                <Card title="LLM配置详情">
                  <Form
                    form={llmForm}
                    layout="vertical"
                    onFinish={handleSaveLlmConfig}
                  >
                    <Form.Item
                      name="id"
                      hidden
                    >
                      <Input />
                    </Form.Item>
                    
                    <Form.Item
                      name="name"
                      label="配置名称"
                      rules={[{ required: true, message: '请输入配置名称' }]}
                    >
                      <Input placeholder="请输入配置名称" />
                    </Form.Item>
                    
                    <Form.Item
                      name="api_key"
                      label="API Key"
                      rules={[{ required: true, message: '请输入API Key' }]}
                    >
                      <Input.Password placeholder="请输入API Key" />
                    </Form.Item>
                    
                    <Form.Item
                      name="model"
                      label="模型"
                      rules={[{ required: true, message: '请选择模型' }]}
                    >
                      <Select placeholder="请选择模型">
                        <Select.Option value="gpt-3.5-turbo">GPT-3.5-Turbo</Select.Option>
                        <Select.Option value="gpt-4">GPT-4</Select.Option>
                        <Select.Option value="gpt-4-turbo">GPT-4-Turbo</Select.Option>
                        <Select.Option value="claude-3-opus">Claude-3-Opus</Select.Option>
                        <Select.Option value="claude-3-sonnet">Claude-3-Sonnet</Select.Option>
                      </Select>
                    </Form.Item>
                    
                    <Form.Item
                      name="temperature"
                      label="温度"
                      rules={[{ required: true, message: '请输入温度' }]}
                    >
                      <Input 
                        type="number" 
                        min={0} 
                        max={1} 
                        step={0.1}
                        placeholder="请输入温度(0-1)" 
                      />
                    </Form.Item>
                    
                    <Form.Item
                      name="is_default"
                      label="设为默认"
                      valuePropName="checked"
                      initialValue={false}
                    >
                      <Switch />
                    </Form.Item>
                    
                    <Form.Item>
                      <Button 
                        type="primary" 
                        htmlType="submit"
                        block
                      >
                        保存
                      </Button>
                    </Form.Item>
                    
                    <Form.Item>
                      <Button 
                        htmlType="button"
                        block
                        onClick={() => llmForm.resetFields()}
                      >
                        重置
                      </Button>
                    </Form.Item>
                  </Form>
                </Card>
              </div>
              
              <div className="w-2/3">
                <Card 
                  title="LLM配置列表" 
                  extra={
                    <Button 
                      type="primary" 
                      icon={<PlusOutlined />}
                      onClick={() => {
                        llmForm.resetFields();
                      }}
                    >
                      新建
                    </Button>
                  }
                >
                  <Table
                    columns={llmConfigColumns}
                    dataSource={llmConfigs}
                    rowKey="id"
                    loading={loading && activeTab === '2'}
                    pagination={{ pageSize: 5 }}
                  />
                </Card>
              </div>
            </div>
          </TabPane>
        </Tabs>
      </div>
    </AdminLayout>
  );
};

export default KnowledgeConfig;
```

### 5. 系统设置页面

```typescript:frontend/src/pages/admin/settings/index.tsx
import { useState, useEffect } from 'react';
import { Tabs, Card, Form, Input, Button, Switch, message, Divider, Upload, Row, Col } from 'antd';
import { UploadOutlined, SaveOutlined } from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

const { TabPane } = Tabs;

interface SystemSettings {
  site_name: string;
  site_logo: string;
  site_description: string;
  admin_email: string;
  enable_registration: boolean;
  enable_public_access: boolean;
  default_page_size: number;
}

interface EmailSettings {
  smtp_server: string;
  smtp_port: number;
  smtp_username: string;
  smtp_password: string;
  smtp_use_tls: boolean;
  from_email: string;
  from_name: string;
}

const Settings = () => {
  const [systemForm] = Form.useForm();
  const [emailForm] = Form.useForm();
  const [loading, setLoading] = useState(false);
  const [activeTab, setActiveTab] = useState('1');

  // 获取系统设置
  const fetchSystemSettings = async () => {
    setLoading(true);
    try {
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/settings/system', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        systemForm.setFieldsValue(data);
      } else {
        // 如果API未实现，使用默认值
        systemForm.setFieldsValue({
          site_name: '企业智能知识库平台',
          site_logo: '',
          site_description: '构建企业内部知识中心，提升知识资产价值，赋能员工高效工作',
          admin_email: 'admin@example.com',
          enable_registration: false,
          enable_public_access: false,
          default_page_size: 10
        });
      }
    } catch (error) {
      console.error('获取系统设置失败', error);
      message.error('获取系统设置失败');
    } finally {
      setLoading(false);
    }
  };

  // 获取邮件设置
  const fetchEmailSettings = async () => {
    setLoading(true);
    try {
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/settings/email', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        emailForm.setFieldsValue(data);
      } else {
        // 如果API未实现，使用默认值
        emailForm.setFieldsValue({
          smtp_server: '',
          smtp_port: 587,
          smtp_username: '',
          smtp_password: '',
          smtp_use_tls: true,
          from_email: 'noreply@example.com',
          from_name: '企业智能知识库平台'
        });
      }
    } catch (error) {
      console.error('获取邮件设置失败', error);
      message.error('获取邮件设置失败');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (activeTab === '1') {
      fetchSystemSettings();
    } else if (activeTab === '2') {
      fetchEmailSettings();
    }
  }, [activeTab]);

  // 保存系统设置
  const handleSaveSystemSettings = async (values: SystemSettings) => {
    setLoading(true);
    try {
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/settings/system', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (response.ok) {
        message.success('系统设置保存成功');
      } else {
        throw new Error('保存失败');
      }
    } catch (error) {
      console.error('保存系统设置失败', error);
      message.error('保存系统设置失败');
    } finally {
      setLoading(false);
    }
  };

  // 保存邮件设置
  const handleSaveEmailSettings = async (values: EmailSettings) => {
    setLoading(true);
    try {
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/settings/email', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (response.ok) {
        message.success('邮件设置保存成功');
      } else {
        throw new Error('保存失败');
      }
    } catch (error) {
      console.error('保存邮件设置失败', error);
      message.error('保存邮件设置失败');
    } finally {
      setLoading(false);
    }
  };

  // 测试邮件设置
  const handleTestEmail = async () => {
    try {
      const values = emailForm.getFieldsValue();
      
      // 实际项目中需要实现后端API
      const response = await fetch('/api/admin/settings/email/test', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (response.ok) {
        message.success('测试邮件发送成功');
      } else {
        throw new Error('测试失败');
      }
    } catch (error) {
      console.error('测试邮件发送失败', error);
      message.error('测试邮件发送失败');
    }
  };

  return (
    <AdminLayout>
      <div className="p-4">
        <h1 className="text-2xl font-bold mb-6">系统设置</h1>
        
        <Tabs 
          activeKey={activeTab} 
          onChange={setActiveTab}
        >
          <TabPane tab="通用设置" key="1">
            <Card>
              <Form
                form={systemForm}
                layout="vertical"
                onFinish={handleSaveSystemSettings}
              >
                <h2 className="text-lg font-semibold mb-4">基础设置</h2>
                
                <Row gutter={16}>
                  <Col span={12}>
                    <Form.Item
                      name="site_name"
                      label="网站名称"
                      rules={[{ required: true, message: '请输入网站名称' }]}
                    >
                      <Input placeholder="请输入网站名称" />
                    </Form.Item>
                  </Col>
                  
                  <Col span={12}>
                    <Form.Item
                      name="admin_email"
                      label="管理员邮箱"
                      rules={[
                        { required: true, message: '请输入管理员邮箱' },
                        { type: 'email', message: '请输入有效的邮箱地址' }
                      ]}
                    >
                      <Input placeholder="请输入管理员邮箱" />
                    </Form.Item>
                  </Col>
                </Row>
                
                <Form.Item
                  name="site_description"
                  label="网站描述"
                >
                  <Input.TextArea rows={2} placeholder="请输入网站描述" />
                </Form.Item>
                
                <Form.Item
                  name="site_logo"
                  label="网站Logo"
                >
                  <Input placeholder="请输入Logo URL" />
                </Form.Item>
                
                <Form.Item
                  label="上传Logo"
                >
                  <Upload>
                    <Button icon={<UploadOutlined />}>选择文件</Button>
                  </Upload>
                </Form.Item>
                
                <Divider />
                
                <h2 className="text-lg font-semibold mb-4">系统配置</h2>
                
                <Row gutter={16}>
                  <Col span={12}>
                    <Form.Item
                      name="enable_registration"
                      label="允许用户注册"
                      valuePropName="checked"
                    >
                      <Switch />
                    </Form.Item>
                  </Col>
                  
                  <Col span={12}>
                    <Form.Item
                      name="enable_public_access"
                      label="允许公开访问"
                      valuePropName="checked"
                    >
                      <Switch />
                    </Form.Item>
                  </Col>
                </Row>
                
                <Form.Item
                  name="default_page_size"
                  label="默认分页大小"
                  rules={[{ required: true, message: '请输入默认分页大小' }]}
                >
                  <Input type="number" min={5} max={100} />
                </Form.Item>
                
                <Form.Item>
                  <Button
                    type="primary"
                    htmlType="submit"
                    icon={<SaveOutlined />}
                    loading={loading}
                  >
                    保存设置
                  </Button>
                </Form.Item>
              </Form>
            </Card>
          </TabPane>
          
          <TabPane tab="邮件设置" key="2">
            <Card>
              <Form
                form={emailForm}
                layout="vertical"
                onFinish={handleSaveEmailSettings}
              >
                <h2 className="text-lg font-semibold mb-4">SMTP设置</h2>
                
                <Row gutter={16}>
                  <Col span={16}>
                    <Form.Item
                      name="smtp_server"
                      label="SMTP服务器"
                      rules={[{ required: true, message: '请输入SMTP服务器' }]}
                    >
                      <Input placeholder="例如: smtp.gmail.com" />
                    </Form.Item>
                  </Col>
                  
                  <Col span={8}>
                    <Form.Item
                      name="smtp_port"
                      label="SMTP端口"
                      rules={[{ required: true, message: '请输入SMTP端口' }]}
                    >
                      <Input type="number" placeholder="例如: 587" />
                    </Form.Item>
                  </Col>
                </Row>
                
                <Row gutter={16}>
                  <Col span={12}>
                    <Form.Item
                      name="smtp_username"
                      label="SMTP用户名"
                      rules={[{ required: true, message: '请输入SMTP用户名' }]}
                    >
                      <Input placeholder="请输入SMTP用户名" />
                    </Form.Item>
                  </Col>
                  
                  <Col span={12}>
                    <Form.Item
                      name="smtp_password"
                      label="SMTP密码"
                      rules={[{ required: true, message: '请输入SMTP密码' }]}
                    >
                      <Input.Password placeholder="请输入SMTP密码" />
                    </Form.Item>
                  </Col>
                </Row>
                
                <Form.Item
                  name="smtp_use_tls"
                  label="使用TLS"
                  valuePropName="checked"
                >
                  <Switch />
                </Form.Item>
                
                <Divider />
                
                <h2 className="text-lg font-semibold mb-4">发送设置</h2>
                
                <Row gutter={16}>
                  <Col span={12}>
                    <Form.Item
                      name="from_email"
                      label="发件人邮箱"
                      rules={[
                        { required: true, message: '请输入发件人邮箱' },
                        { type: 'email', message: '请输入有效的邮箱地址' }
                      ]}
                    >
                      <Input placeholder="请输入发件人邮箱

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统开发计划

## 前端管理界面实现(续)

### 5. 系统设置页面(续)

```typescript:frontend/src/pages/admin/settings/index.tsx
                    <Form.Item
                      name="from_email"
                      label="发件人邮箱"
                      rules={[
                        { required: true, message: '请输入发件人邮箱' },
                        { type: 'email', message: '请输入有效的邮箱地址' }
                      ]}
                    >
                      <Input placeholder="请输入发件人邮箱" />
                    </Form.Item>
                  </Col>
                  
                  <Col span={12}>
                    <Form.Item
                      name="from_name"
                      label="发件人名称"
                      rules={[{ required: true, message: '请输入发件人名称' }]}
                    >
                      <Input placeholder="请输入发件人名称" />
                    </Form.Item>
                  </Col>
                </Row>
                
                <div className="flex space-x-4">
                  <Form.Item>
                    <Button
                      type="primary"
                      htmlType="submit"
                      icon={<SaveOutlined />}
                      loading={loading}
                    >
                      保存设置
                    </Button>
                  </Form.Item>
                  
                  <Button
                    onClick={handleTestEmail}
                  >
                    发送测试邮件
                  </Button>
                </div>
              </Form>
            </Card>
          </TabPane>
        </Tabs>
      </div>
    </AdminLayout>
  );
};

export default Settings;
```

## 三、后端API实现(续)

### 1. 创建系统设置模型和API

```python:backend/app/models/setting.py
from sqlalchemy import Column, Integer, String, Text, Boolean

from app.db.base_class import Base

class Setting(Base):
    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(50), unique=True, index=True, nullable=False)
    value = Column(Text, nullable=True)
    description = Column(String(200), nullable=True)
```

```python:backend/app/schemas/setting.py
from typing import Optional, Dict, Any
from pydantic import BaseModel, EmailStr

# 系统设置模型
class SystemSettings(BaseModel):
    site_name: str
    site_logo: Optional[str] = None
    site_description: Optional[str] = None
    admin_email: EmailStr
    enable_registration: bool = False
    enable_public_access: bool = False
    default_page_size: int = 10

# 邮件设置模型
class EmailSettings(BaseModel):
    smtp_server: str
    smtp_port: int
    smtp_username: str
    smtp_password: str
    smtp_use_tls: bool = True
    from_email: EmailStr
    from_name: str
```

```python:backend/app/crud/crud_setting.py
from typing import Any, Dict, List, Optional, Union

from sqlalchemy.orm import Session

from app.crud.base import CRUDBase
from app.models.setting import Setting

class CRUDSetting(CRUDBase[Setting, Any, Any]):
    def get_by_key(self, db: Session, *, key: str) -> Optional[Setting]:
        return db.query(Setting).filter(Setting.key == key).first()
    
    def set_value(self, db: Session, *, key: str, value: str, description: Optional[str] = None) -> Setting:
        setting = self.get_by_key(db, key=key)
        if setting:
            setting.value = value
            if description:
                setting.description = description
            db.commit()
            db.refresh(setting)
            return setting
        else:
            db_obj = Setting(
                key=key,
                value=value,
                description=description
            )
            db.add(db_obj)
            db.commit()
            db.refresh(db_obj)
            return db_obj
    
    def get_all_as_dict(self, db: Session) -> Dict[str, str]:
        settings = db.query(Setting).all()
        return {setting.key: setting.value for setting in settings}
    
    def get_by_prefix(self, db: Session, *, prefix: str) -> Dict[str, str]:
        settings = db.query(Setting).filter(Setting.key.startswith(prefix)).all()
        return {setting.key[len(prefix):]: setting.value for setting in settings}
    
    def set_from_dict(self, db: Session, *, data: Dict[str, Any], prefix: str = "") -> None:
        for key, value in data.items():
            full_key = f"{prefix}{key}" if prefix else key
            value_str = str(value) if value is not None else None
            self.set_value(db, key=full_key, value=value_str)

setting = CRUDSetting(Setting)
```

```python:backend/app/api/api_v1/endpoints/admin.py
from typing import Any, Dict, List

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from pydantic import EmailStr
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps
from app.core.config import settings
from app.utils.email import send_test_email

router = APIRouter()

@router.get("/dashboard/stats", response_model=Dict[str, Any])
def get_dashboard_stats(
    db: Session = Depends(deps.get_db),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取仪表盘统计数据。
    """
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 获取各种统计数据
    user_count = db.query(models.User).count()
    organization_count = db.query(models.Organization).count()
    
    # 这里可以添加其他统计逻辑，例如知识库数量和查询次数
    # 目前使用模拟数据
    knowledge_base_count = 3  # 模拟数据
    total_queries = 120  # 模拟数据
    
    return {
        "userCount": user_count,
        "organizationCount": organization_count,
        "knowledgeBaseCount": knowledge_base_count,
        "totalQueries": total_queries
    }

@router.get("/settings/system", response_model=schemas.SystemSettings)
def get_system_settings(
    db: Session = Depends(deps.get_db),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取系统设置。
    """
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 从数据库获取所有系统设置
    system_settings = crud.setting.get_by_prefix(db, prefix="system.")
    
    # 设置默认值
    default_settings = {
        "site_name": "企业智能知识库平台",
        "site_logo": "",
        "site_description": "构建企业内部知识中心，提升知识资产价值，赋能员工高效工作",
        "admin_email": settings.FIRST_ADMIN_EMAIL,
        "enable_registration": "False",
        "enable_public_access": "False",
        "default_page_size": "10"
    }
    
    # 合并默认值和数据库值
    result = {}
    for key, default_value in default_settings.items():
        db_value = system_settings.get(key)
        if key in ["enable_registration", "enable_public_access"]:
            result[key] = db_value == "True" if db_value is not None else default_value == "True"
        elif key == "default_page_size":
            result[key] = int(db_value) if db_value is not None else int(default_value)
        else:
            result[key] = db_value if db_value is not None else default_value
    
    return schemas.SystemSettings(**result)

@router.put("/settings/system", response_model=schemas.SystemSettings)
def update_system_settings(
    *,
    db: Session = Depends(deps.get_db),
    settings_in: schemas.SystemSettings,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新系统设置。
    """
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 保存设置到数据库
    settings_dict = settings_in.dict()
    crud.setting.set_from_dict(db, data=settings_dict, prefix="system.")
    
    return settings_in

@router.get("/settings/email", response_model=schemas.EmailSettings)
def get_email_settings(
    db: Session = Depends(deps.get_db),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取邮件设置。
    """
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 从数据库获取所有邮件设置
    email_settings = crud.setting.get_by_prefix(db, prefix="email.")
    
    # 设置默认值
    default_settings = {
        "smtp_server": "",
        "smtp_port": "587",
        "smtp_username": "",
        "smtp_password": "",
        "smtp_use_tls": "True",
        "from_email": "noreply@example.com",
        "from_name": "企业智能知识库平台"
    }
    
    # 合并默认值和数据库值
    result = {}
    for key, default_value in default_settings.items():
        db_value = email_settings.get(key)
        if key == "smtp_use_tls":
            result[key] = db_value == "True" if db_value is not None else default_value == "True"
        elif key == "smtp_port":
            result[key] = int(db_value) if db_value is not None else int(default_value)
        else:
            result[key] = db_value if db_value is not None else default_value
    
    return schemas.EmailSettings(**result)

@router.put("/settings/email", response_model=schemas.EmailSettings)
def update_email_settings(
    *,
    db: Session = Depends(deps.get_db),
    settings_in: schemas.EmailSettings,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新邮件设置。
    """
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 保存设置到数据库
    settings_dict = settings_in.dict()
    crud.setting.set_from_dict(db, data=settings_dict, prefix="email.")
    
    return settings_in

@router.post("/settings/email/test", status_code=200)
def test_email_settings(
    *,
    db: Session = Depends(deps.get_db),
    settings_in: schemas.EmailSettings,
    background_tasks: BackgroundTasks,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    测试邮件设置。
    """
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 发送测试邮件
    background_tasks.add_task(
        send_test_email,
        email_to=current_user.email,
        settings=settings_in
    )
    
    return {"message": "测试邮件已发送"}
```

### 2. 添加邮件功能工具类

```python:backend/app/utils/email.py
import logging
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Any, Dict, List, Optional

from app.schemas.setting import EmailSettings

def send_email(
    *,
    email_to: str,
    subject: str,
    html_content: str,
    settings: EmailSettings
) -> None:
    """
    发送电子邮件
    """
    try:
        # 创建邮件
        message = MIMEMultipart()
        message["From"] = f"{settings.from_name} <{settings.from_email}>"
        message["To"] = email_to
        message["Subject"] = subject
        
        # 添加HTML内容
        message.attach(MIMEText(html_content, "html"))
        
        # 连接SMTP服务器
        if settings.smtp_use_tls:
            server = smtplib.SMTP(settings.smtp_server, settings.smtp_port)
            server.starttls()
        else:
            server = smtplib.SMTP(settings.smtp_server, settings.smtp_port)
        
        # 登录
        if settings.smtp_username:
            server.login(settings.smtp_username, settings.smtp_password)
        
        # 发送邮件
        server.sendmail(settings.from_email, email_to, message.as_string())
        
        # 关闭连接
        server.quit()
        
    except Exception as e:
        logging.error(f"发送邮件失败: {e}")
        raise

def send_test_email(email_to: str, settings: EmailSettings) -> None:
    """
    发送测试邮件
    """
    subject = "测试邮件 - 企业智能知识库平台"
    html_content = f"""
    <html>
        <body>
            <h1>测试邮件</h1>
            <p>这是一封测试邮件，用于验证邮件设置是否正确。</p>
            <p>如果您收到此邮件，说明您的邮件设置正确。</p>
            <hr>
            <p>企业智能知识库平台</p>
        </body>
    </html>
    """
    
    send_email(
        email_to=email_to,
        subject=subject,
        html_content=html_content,
        settings=settings
    )
```

### 3. 注册管理员API路由

```python:backend/app/api/api_v1/api.py
from fastapi import APIRouter

from app.api.api_v1.endpoints import auth, users, organizations, admin

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["认证"])
api_router.include_router(users.router, prefix="/users", tags=["用户"])
api_router.include_router(organizations.router, prefix="/organizations", tags=["组织"])
api_router.include_router(admin.router, prefix="/admin", tags=["管理"])
```

## 四、首页实现

```typescript:frontend/src/pages/index.tsx
import { useEffect, useState } from 'react';
import { Layout, Menu, Input, Button, Typography, Card, List, Tag, Spin } from 'antd';
import { SearchOutlined, UserOutlined, LogoutOutlined, AppstoreOutlined } from '@ant-design/icons';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { getToken, clearToken } from '@/utils/auth';

const { Header, Content, Sider } = Layout;
const { Title, Paragraph } = Typography;
const { Search } = Input;

interface KnowledgeItem {
  id: number;
  title: string;
  description: string;
  category: string;
  updated_at: string;
}

const Home = () => {
  const [collapsed, setCollapsed] = useState(false);
  const [loading, setLoading] = useState(true);
  const [knowledgeItems, setKnowledgeItems] = useState<KnowledgeItem[]>([]);
  const [currentUser, setCurrentUser] = useState({ username: '', is_admin: false });
  const router = useRouter();

  useEffect(() => {
    const fetchUserInfo = async () => {
      try {
        const response = await fetch('/api/users/me', {
          headers: {
            'Authorization': `Bearer ${getToken()}`
          }
        });
        
        if (response.ok) {
          const user = await response.json();
          setCurrentUser(user);
        }
      } catch (error) {
        console.error('获取用户信息失败', error);
      }
    };

    const fetchRecentKnowledge = async () => {
      setLoading(true);
      try {
        // 这里应该调用实际的API获取最近的知识条目
        // 目前使用模拟数据
        const mockData: KnowledgeItem[] = [
          {
            id: 1,
            title: '产品使用手册',
            description: '详细介绍产品的功能和使用方法',
            category: '使用手册',
            updated_at: '2023-05-20'
          },
          {
            id: 2,
            title: '常见问题解答',
            description: '解答客户常见的技术问题和使用疑问',
            category: 'FAQ',
            updated_at: '2023-06-15'
          },
          {
            id: 3,
            title: '销售流程指南',
            description: '规范化的销售流程和注意事项',
            category: '销售',
            updated_at: '2023-07-02'
          },
          {
            id: 4,
            title: '新员工入职指南',
            description: '帮助新员工快速了解公司和融入团队',
            category: '人力资源',
            updated_at: '2023-04-10'
          },
        ];
        
        setKnowledgeItems(mockData);
      } catch (error) {
        console.error('获取知识条目失败', error);
      } finally {
        setLoading(false);
      }
    };

    fetchUserInfo();
    fetchRecentKnowledge();
  }, []);

  const handleSearch = (value: string) => {
    if (value) {
      router.push(`/search?q=${encodeURIComponent(value)}`);
    }
  };

  const handleLogout = () => {
    clearToken();
    router.push('/login');
  };

  const getCategoryColor = (category: string) => {
    const colorMap: Record<string, string> = {
      '使用手册': 'blue',
      'FAQ': 'green',
      '销售': 'orange',
      '人力资源': 'purple',
    };
    return colorMap[category] || 'default';
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Header className="bg-white flex justify-between items-center px-6 shadow-sm">
        <div className="flex items-center">
          <div className="text-xl font-bold mr-8">企业智能知识库</div>
          <Search
            placeholder="搜索知识..."
            onSearch={handleSearch}
            style={{ width: 400 }}
            size="middle"
            enterButton={<Button icon={<SearchOutlined />}>搜索</Button>}
          />
        </div>
        <div className="flex items-center">
          <Button type="text" icon={<UserOutlined />} className="mr-2">{currentUser.username}</Button>
          {currentUser.is_admin && (
            <Link href="/admin/dashboard" passHref>
              <Button type="text" icon={<AppstoreOutlined />} className="mr-2">管理后台</Button>
            </Link>
          )}
          <Button type="text" icon={<LogoutOutlined />} onClick={handleLogout}>退出</Button>
        </div>
      </Header>
      
      <Layout>
        <Sider 
          width={200} 
          collapsible 
          collapsed={collapsed} 
          onCollapse={setCollapsed}
          className="bg-white"
        >
          <Menu
            mode="inline"
            defaultSelectedKeys={['1']}
            style={{ height: '100%', borderRight: 0 }}
            items={[
              { key: '1', label: '首页', icon: <AppstoreOutlined /> },
              { key: '2', label: '产品文档', icon: <AppstoreOutlined /> },
              { key: '3', label: '技术支持', icon: <AppstoreOutlined /> },
              { key: '4', label: '销售资料', icon: <AppstoreOutlined /> },
              { key: '5', label: '人力资源', icon: <AppstoreOutlined /> },
            ]}
          />
        </Sider>
        
        <Layout className="p-6 bg-gray-50">
          <Content className="mb-6">
            <Card>
              <Title level={2}>欢迎使用企业智能知识库</Title>
              <Paragraph>
                企业智能知识库是一个集中管理企业知识资产的平台，帮助您快速获取和共享知识，提高工作效率。
              </Paragraph>
              <Search
                placeholder="输入问题，智能助手为您解答..."
                enterButton="提问"
                size="large"
                onSearch={value => console.log(value)}
              />
            </Card>
          </Content>
          
          <Card title="最近更新的知识" className="mb-6">
            {loading ? (
              <div className="flex justify-center py-8">
                <Spin size="large" tip="加载中..." />
              </div>
            ) : (
              <List
                dataSource={knowledgeItems}
                renderItem={item => (
                  <List.Item
                    actions={[
                      <Button key="view" type="link">查看</Button>,
                      <Button key="share" type="link">分享</Button>
                    ]}
                  >
                    <List.Item.Meta
                      title={<a href={`/knowledge/${item.id}`}>{item.title}</a>}
                      description={item.description}
                    />
                    <div className="flex flex-col items-end">
                      <Tag color={getCategoryColor(item.category)}>{item.category}</Tag>
                      <div className="text-sm text-gray-500 mt-1">更新于: {item.updated_at}</div>
                    </div>
                  </List.Item>
                )}
              />
            )}
          </Card>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <Card title="常用工具" className="h-full">
              <div className="grid grid-cols-2 gap-4">
                <Button size="large" block>知识管理</Button>
                <Button size="large" block>文档上传</Button>
                <Button size="large" block>问答中心</Button>
                <Button size="large" block>智能助手</Button>
              </div>
            </Card>
            
            <Card title="快速入口" className="h-full">
              <div className="grid grid-cols-2 gap-4">
                <Button size="large" block>我的收藏</Button>
                <Button size="large" block>最近浏览</Button>
                <Button size="large" block>个人设置</Button>
                <Button size="large" block>帮助中心</Button>
              </div>
            </Card>
          </div>
        </Layout>
      </Layout>
    </Layout>
  );
};

export default Home;
```

## 五、总结与下一步

至此，我们已经完成了：

1. **用户认证系统**：
   - 登录页面和认证逻辑
   - 路由守卫确保未登录用户重定向到登录页
   - 默认管理员账户配置

2. **组织管理**：
   - 组织模型和关系设计
   - 组织管理页面和API

3. **用户管理**：
   - 用户模型扩展
   - 用户管理页面和API
   - 权限控制逻辑

4. **管理员界面**：
   - 管理员布局组件
   - 仪表盘
   - 系统设置
   - 知识库配置

5. **前端首页**：
   - 基础布局和功能展示
   - 用户状态管理

### 下一步开发计划：

1. **知识库核心功能**：
   - 知识条目的创建、编辑、删除
   - 知识分类和标签管理
   - 文档上传和解析

2. **搜索和查询功能**：
   - 基本搜索功能实现
   - 高级过滤和排序
   - 搜索结果展示

3. **智能问答系统**：
   - 接入大语言模型
   - 构建问答界面
   - 实现知识库检索与回答生成

4. **数据统计与分析**：
   - 用户活跃度统计
   - 知识条目使用情况分析
   - 搜索关键词分析

这些功能将进一步完善企业智能知识库平台，为用户提供更全面的知识管理和检索服务。

---

_**User**_

继续完成设计

---

_**Assistant**_



---

# 继续完成系统设计与开发

## 一、知识库核心功能实现

### 1. 知识条目模型设计

```python:backend/app/models/knowledge.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Table
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base_class import Base

# 知识条目与标签的多对多关系表
knowledge_tag = Table(
    "knowledge_tag",
    Base.metadata,
    Column("knowledge_id", Integer, ForeignKey("knowledge.id"), primary_key=True),
    Column("tag_id", Integer, ForeignKey("tag.id"), primary_key=True)
)

class Category(Base):
    """知识分类模型"""
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), index=True, nullable=False)
    description = Column(Text, nullable=True)
    parent_id = Column(Integer, ForeignKey("category.id"), nullable=True)
    organization_id = Column(Integer, ForeignKey("organization.id"), nullable=True)
    
    # 关系
    parent = relationship("Category", remote_side=[id], backref="children")
    knowledge_items = relationship("Knowledge", back_populates="category")
    organization = relationship("Organization", back_populates="categories")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class Tag(Base):
    """知识标签模型"""
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), index=True, nullable=False)
    color = Column(String(20), nullable=True)
    organization_id = Column(Integer, ForeignKey("organization.id"), nullable=True)
    
    # 关系
    knowledge_items = relationship("Knowledge", secondary=knowledge_tag, back_populates="tags")
    organization = relationship("Organization", back_populates="tags")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Knowledge(Base):
    """知识条目模型"""
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), index=True, nullable=False)
    content = Column(Text, nullable=True)
    summary = Column(Text, nullable=True)
    status = Column(String(20), default="draft")  # draft, published, archived
    view_count = Column(Integer, default=0)
    is_public = Column(Boolean, default=False)
    
    # 关系
    creator_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    creator = relationship("User", foreign_keys=[creator_id], back_populates="created_knowledge")
    
    last_editor_id = Column(Integer, ForeignKey("user.id"), nullable=True)
    last_editor = relationship("User", foreign_keys=[last_editor_id])
    
    category_id = Column(Integer, ForeignKey("category.id"), nullable=True)
    category = relationship("Category", back_populates="knowledge_items")
    
    organization_id = Column(Integer, ForeignKey("organization.id"), nullable=False)
    organization = relationship("Organization", back_populates="knowledge_items")
    
    tags = relationship("Tag", secondary=knowledge_tag, back_populates="knowledge_items")
    attachments = relationship("Attachment", back_populates="knowledge_item")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class Attachment(Base):
    """附件模型"""
    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String(255), nullable=False)
    file_path = Column(String(500), nullable=False)
    file_size = Column(Integer, nullable=True)
    file_type = Column(String(100), nullable=True)
    
    # 关系
    knowledge_id = Column(Integer, ForeignKey("knowledge.id"), nullable=False)
    knowledge_item = relationship("Knowledge", back_populates="attachments")
    
    uploader_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    uploader = relationship("User")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

### 2. 更新用户模型添加知识库关联

```python:backend/app/models/user.py
# ... existing code ...

class User(Base):
    # ... existing code ...
    
    # 添加用户创建的知识条目关系
    created_knowledge = relationship("Knowledge", back_populates="creator", foreign_keys="[Knowledge.creator_id]")
    
    # ... existing code ...
```

### 3. 更新组织模型添加知识库关联

```python:backend/app/models/organization.py
# ... existing code ...

from sqlalchemy.orm import relationship

class Organization(Base):
    # ... existing code ...
    
    # 添加组织与知识库的关系
    knowledge_items = relationship("Knowledge", back_populates="organization")
    categories = relationship("Category", back_populates="organization")
    tags = relationship("Tag", back_populates="organization")
    
    # ... existing code ...
```

### 4. 知识条目Schema定义

```python:backend/app/schemas/knowledge.py
from typing import Optional, List, Any
from datetime import datetime
from pydantic import BaseModel

# 分类相关模型
class CategoryBase(BaseModel):
    name: str
    description: Optional[str] = None
    parent_id: Optional[int] = None
    organization_id: Optional[int] = None

class CategoryCreate(CategoryBase):
    pass

class CategoryUpdate(CategoryBase):
    name: Optional[str] = None

class CategoryInDBBase(CategoryBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class Category(CategoryInDBBase):
    pass

class CategoryWithChildren(Category):
    children: List['CategoryWithChildren'] = []

# 标签相关模型
class TagBase(BaseModel):
    name: str
    color: Optional[str] = None
    organization_id: Optional[int] = None

class TagCreate(TagBase):
    pass

class TagUpdate(TagBase):
    name: Optional[str] = None

class TagInDBBase(TagBase):
    id: int
    created_at: datetime

    class Config:
        orm_mode = True

class Tag(TagInDBBase):
    pass

# 知识条目相关模型
class KnowledgeBase(BaseModel):
    title: str
    content: Optional[str] = None
    summary: Optional[str] = None
    status: str = "draft"
    is_public: bool = False
    category_id: Optional[int] = None
    organization_id: int

class KnowledgeCreate(KnowledgeBase):
    tag_ids: Optional[List[int]] = []

class KnowledgeUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    summary: Optional[str] = None
    status: Optional[str] = None
    is_public: Optional[bool] = None
    category_id: Optional[int] = None
    tag_ids: Optional[List[int]] = None

class KnowledgeInDBBase(KnowledgeBase):
    id: int
    creator_id: int
    last_editor_id: Optional[int] = None
    view_count: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class Knowledge(KnowledgeInDBBase):
    tags: List[Tag] = []
    category: Optional[Category] = None

# 附件相关模型
class AttachmentBase(BaseModel):
    filename: str
    file_path: str
    file_size: Optional[int] = None
    file_type: Optional[str] = None
    knowledge_id: int

class AttachmentCreate(AttachmentBase):
    pass

class AttachmentUpdate(AttachmentBase):
    filename: Optional[str] = None
    file_path: Optional[str] = None

class AttachmentInDBBase(AttachmentBase):
    id: int
    uploader_id: int
    created_at: datetime

    class Config:
        orm_mode = True

class Attachment(AttachmentInDBBase):
    pass
```

### 5. 知识分类API实现

```python:backend/app/api/api_v1/endpoints/categories.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps

router = APIRouter()

@router.get("/", response_model=List[schemas.Category])
def read_categories(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    parent_id: Optional[int] = None,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取知识分类列表。
    """
    # 根据用户所属组织获取分类
    categories = crud.category.get_by_organization(
        db, 
        organization_id=current_user.organization_id,
        parent_id=parent_id,
        skip=skip, 
        limit=limit
    )
    return categories

@router.get("/tree", response_model=List[schemas.CategoryWithChildren])
def read_categories_tree(
    db: Session = Depends(deps.get_db),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取树形结构的知识分类。
    """
    categories_tree = crud.category.get_tree(db, organization_id=current_user.organization_id)
    return categories_tree

@router.post("/", response_model=schemas.Category)
def create_category(
    *,
    db: Session = Depends(deps.get_db),
    category_in: schemas.CategoryCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新知识分类。
    """
    # 设置组织ID
    if not category_in.organization_id:
        category_in.organization_id = current_user.organization_id
    
    # 验证组织ID
    if category_in.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为其他组织创建分类")
    
    # 验证父分类
    if category_in.parent_id:
        parent = crud.category.get(db, id=category_in.parent_id)
        if not parent:
            raise HTTPException(status_code=404, detail="父分类不存在")
        if parent.organization_id != category_in.organization_id:
            raise HTTPException(status_code=400, detail="父分类与当前组织不匹配")
    
    category = crud.category.create(db=db, obj_in=category_in)
    return category

@router.put("/{id}", response_model=schemas.Category)
def update_category(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    category_in: schemas.CategoryUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新知识分类。
    """
    category = crud.category.get(db=db, id=id)
    if not category:
        raise HTTPException(status_code=404, detail="分类不存在")
    
    # 验证权限
    if category.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权更新此分类")
    
    # 验证父分类
    if category_in.parent_id and category_in.parent_id != category.parent_id:
        parent = crud.category.get(db, id=category_in.parent_id)
        if not parent:
            raise HTTPException(status_code=404, detail="父分类不存在")
        if parent.organization_id != category.organization_id:
            raise HTTPException(status_code=400, detail="父分类与当前分类组织不匹配")
        # 确保不会形成循环
        if id == category_in.parent_id or crud.category.is_descendant(db, id, category_in.parent_id):
            raise HTTPException(status_code=400, detail="不能将分类设为自身的子分类或后代分类")
    
    category = crud.category.update(db=db, db_obj=category, obj_in=category_in)
    return category

@router.delete("/{id}", response_model=schemas.Category)
def delete_category(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除知识分类。
    """
    category = crud.category.get(db=db, id=id)
    if not category:
        raise HTTPException(status_code=404, detail="分类不存在")
    
    # 验证权限
    if category.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权删除此分类")
    
    # 检查是否有子分类
    children_count = db.query(models.Category).filter(models.Category.parent_id == id).count()
    if children_count > 0:
        raise HTTPException(status_code=400, detail="此分类下有子分类，无法删除")
    
    # 检查是否有关联的知识条目
    knowledge_count = db.query(models.Knowledge).filter(models.Knowledge.category_id == id).count()
    if knowledge_count > 0:
        raise HTTPException(status_code=400, detail="此分类下有知识条目，无法删除")
    
    category = crud.category.remove(db=db, id=id)
    return category
```

### 6. 知识条目API实现

```python:backend/app/api/api_v1/endpoints/knowledge.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, File, UploadFile, Form
from sqlalchemy.orm import Session
import json

from app import crud, models, schemas
from app.api import deps
from app.utils.file_storage import save_upload_file

router = APIRouter()

@router.get("/", response_model=List[schemas.Knowledge])
def read_knowledge_items(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    category_id: Optional[int] = None,
    tag_id: Optional[int] = None,
    status: Optional[str] = None,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取知识条目列表。
    """
    # 根据用户所属组织获取知识条目
    knowledge_items = crud.knowledge.get_multi_by_filters(
        db, 
        organization_id=current_user.organization_id,
        category_id=category_id,
        tag_id=tag_id,
        status=status,
        skip=skip, 
        limit=limit
    )
    return knowledge_items

@router.post("/", response_model=schemas.Knowledge)
def create_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    knowledge_in: schemas.KnowledgeCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新知识条目。
    """
    # 设置组织ID
    if not knowledge_in.organization_id:
        knowledge_in.organization_id = current_user.organization_id
    
    # 验证组织ID
    if knowledge_in.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为其他组织创建知识条目")
    
    # 验证分类
    if knowledge_in.category_id:
        category = crud.category.get(db, id=knowledge_in.category_id)
        if not category:
            raise HTTPException(status_code=404, detail="分类不存在")
        if category.organization_id != knowledge_in.organization_id:
            raise HTTPException(status_code=400, detail="分类与当前组织不匹配")
    
    # 验证标签
    tag_ids = knowledge_in.tag_ids or []
    if tag_ids:
        for tag_id in tag_ids:
            tag = crud.tag.get(db, id=tag_id)
            if not tag:
                raise HTTPException(status_code=404, detail=f"标签ID {tag_id} 不存在")
            if tag.organization_id != knowledge_in.organization_id:
                raise HTTPException(status_code=400, detail=f"标签ID {tag_id} 与当前组织不匹配")
    
    # 创建知识条目
    knowledge = crud.knowledge.create_with_tags(
        db=db, 
        obj_in=knowledge_in, 
        creator_id=current_user.id,
        tag_ids=tag_ids
    )
    return knowledge

@router.get("/{id}", response_model=schemas.Knowledge)
def read_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取知识条目详情。
    """
    knowledge = crud.knowledge.get(db=db, id=id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 权限验证：用户只能查看自己组织的知识条目
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权查看此知识条目")
    
    # 增加查看次数
    crud.knowledge.increment_view_count(db=db, db_obj=knowledge)
    
    return knowledge

@router.put("/{id}", response_model=schemas.Knowledge)
def update_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    knowledge_in: schemas.KnowledgeUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新知识条目。
    """
    knowledge = crud.knowledge.get(db=db, id=id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 权限验证
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权更新此知识条目")
    
    # 验证分类
    if knowledge_in.category_id:
        category = crud.category.get(db, id=knowledge_in.category_id)
        if not category:
            raise HTTPException(status_code=404, detail="分类不存在")
        if category.organization_id != knowledge.organization_id:
            raise HTTPException(status_code=400, detail="分类与知识条目所属组织不匹配")
    
    # 更新知识条目
    knowledge = crud.knowledge.update_with_tags(
        db=db, 
        db_obj=knowledge, 
        obj_in=knowledge_in,
        last_editor_id=current_user.id
    )
    return knowledge

@router.delete("/{id}", response_model=schemas.Knowledge)
def delete_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除知识条目。
    """
    knowledge = crud.knowledge.get(db=db, id=id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 权限验证
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权删除此知识条目")
    
    knowledge = crud.knowledge.remove(db=db, id=id)
    return knowledge

@router.post("/{id}/attachments", response_model=schemas.Attachment)
def upload_attachment(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    file: UploadFile = File(...),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    上传知识条目附件。
    """
    knowledge = crud.knowledge.get(db=db, id=id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 权限验证
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为此知识条目上传附件")
    
    # 保存文件
    file_path, file_size = save_upload_file(file, f"knowledge_{id}")
    
    # 创建附件记录
    attachment_in = schemas.AttachmentCreate(
        filename=file.filename,
        file_path=file_path,
        file_size=file_size,
        file_type=file.content_type,
        knowledge_id=id
    )
    attachment = crud.attachment.create_with_uploader(
        db=db, 
        obj_in=attachment_in, 
        uploader_id=current_user.id
    )
    return attachment
```

### 7. 标签API实现

```python:backend/app/api/api_v1/endpoints/tags.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps

router = APIRouter()

@router.get("/", response_model=List[schemas.Tag])
def read_tags(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取标签列表。
    """
    # 根据用户所属组织获取标签
    tags = crud.tag.get_by_organization(
        db, 
        organization_id=current_user.organization_id,
        skip=skip, 
        limit=limit
    )
    return tags

@router.post("/", response_model=schemas.Tag)
def create_tag(
    *,
    db: Session = Depends(deps.get_db),
    tag_in: schemas.TagCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新标签。
    """
    # 设置组织ID
    if not tag_in.organization_id:
        tag_in.organization_id = current_user.organization_id
    
    # 验证组织ID
    if tag_in.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为其他组织创建标签")
    
    # 检查标签名是否已存在
    existing_tag = crud.tag.get_by_name_and_organization(
        db, 
        name=tag_in.name, 
        organization_id=tag_in.organization_id
    )
    if existing_tag:
        raise HTTPException(status_code=400, detail="标签名已存在")
    
    tag = crud.tag.create(db=db, obj_in=tag_in)
    return tag

@router.put("/{id}", response_model=schemas.Tag)
def update_tag(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    tag_in: schemas.TagUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新标签。
    """
    tag = crud.tag.get(db=db, id=id)
    if not tag:
        raise HTTPException(status_code=404, detail="标签不存在")
    
    # 验证权限
    if tag.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权更新此标签")
    
    # 检查标签名是否已存在
    if tag_in.name and tag_in.name != tag.name:
        existing_tag = crud.tag.get_by_name_and_organization(
            db, 
            name=tag_in.name, 
            organization_id=tag.organization_id
        )
        if existing_tag:
            raise HTTPException(status_code=400, detail="标签名已存在")
    
    tag = crud.tag.update(db=db, db_obj=tag, obj_in=tag_in)
    return tag

@router.delete("/{id}", response_model=schemas.Tag)
def delete_tag(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除标签。
    """
    tag = crud.tag.get(db=db, id=id)
    if not tag:
        raise HTTPException(status_code=404, detail="标签不存在")
    
    # 验证权限
    if tag.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权删除此标签")
    
    # 检查关联的知识条目数量
    knowledge_count = db.query(models.knowledge_tag).filter(models.knowledge_tag.c.tag_id == id).count()
    if knowledge_count > 0:
        raise HTTPException(status_code=400, detail=f"此标签关联了{knowledge_count}个知识条目，无法删除")
    
    tag = crud.tag.remove(db=db, id=id)
    return tag
```

## 二、搜索和查询功能实现

### 1. 添加文件存储工具

```python:backend/app/utils/file_storage.py
import os
import shutil
from typing import Tuple
from pathlib import Path
import uuid
from fastapi import UploadFile

from app.core.config import settings

# 配置文件存储路径
UPLOAD_DIR = Path(settings.UPLOAD_DIR)

def ensure_dir_exists(path: Path) -> None:
    """确保目录存在"""
    path.mkdir(parents=True, exist_ok=True)

def get_file_path(prefix: str, filename: str) -> Path:
    """生成文件存储路径"""
    # 使用UUID避免文件名冲突
    unique_filename = f"{uuid.uuid4().hex}_{filename}"
    # 按年月组织文件
    from datetime import datetime
    now = datetime.now()
    year_month = now.strftime("%Y/%m")
    
    # 构建完整路径
    dir_path = UPLOAD_DIR / year_month / prefix
    ensure_dir_exists(dir_path)
    
    return dir_path / unique_filename

def save_upload_file(upload_file: UploadFile, prefix: str = "") -> Tuple[str, int]:
    """
    保存上传的文件
    返回: (相对路径, 文件大小)
    """
    # 获取文件路径
    file_path = get_file_path(prefix, upload_file.filename)
    
    # 保存文件
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(upload_file.file, buffer)
    
    # 获取文件大小
    file_size = os.path.getsize(file_path)
    
    # 返回相对路径（用于数据库存储）
    relative_path = str(file_path.relative_to(UPLOAD_DIR))
    
    return relative_path, file_size

def delete_file(file_path: str) -> bool:
    """删除文件"""
    full_path = UPLOAD_DIR / file_path
    try:
        if os.path.exists(full_path):
            os.remove(full_path)
            return True
        return False
    except Exception as e:
        print(f"删除文件失败: {e}")
        return False
```

### 2. 搜索API实现

```python:backend/app/api/api_v1/endpoints/search.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import or_, func

from app import crud, models, schemas
from app.api import deps

router = APIRouter()

@router.get("/", response_model=List[schemas.Knowledge])
def search_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    q: str,
    category_id: Optional[int] = None,
    tag_id: Optional[int] = None,
    skip: int = 0,
    limit: int = 20,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    搜索知识条目。
    """
    # 基本查询条件：用户组织内的条目
    query = db.query(models.Knowledge).filter(
        models.Knowledge.organization_id == current_user.organization_id
    )
    
    # 添加搜索条件
    if q:
        search_term = f"%{q}%"
        query = query.filter(
            or_(
                models.Knowledge.title.ilike(search_term),
                models.Knowledge.content.ilike(search_term),
                models.Knowledge.summary.ilike(search_term)
            )
        )
    
    # 分类过滤
    if category_id:
        query = query.filter(models.Knowledge.category_id == category_id)
    
    # 标签过滤
    if tag_id:
        query = query.join(
            models.knowledge_tag,
            models.Knowledge.id == models.knowledge_tag.c.knowledge_id
        ).filter(models.knowledge_tag.c.tag_id == tag_id)
    
    # 只返回已发布的条目
    query = query.filter(models.Knowledge.status == "published")
    
    # 执行查询
    total = query.count()
    items = query.order_by(models.Knowledge.updated_at.desc()).offset(skip).limit(limit).all()
    
    return items

@router.get("/suggest", response_model=List[str])
def suggest_search_terms(
    *,
    db: Session = Depends(deps.get_db),
    q: str,
    limit: int = 10,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取搜索建议。基于标题生成建议。
    """
    if not q or len(q) < 2:
        return []
    
    search_term = f"%{q}%"
    
    # 查询匹配的标题
    query = db.query(models.Knowledge.title).filter(
        models.Knowledge.organization_id == current_user.organization_id,
        models.Knowledge.title.ilike(search_term),
        models.Knowledge.status == "published"
    )
    
    suggestions = [item.title for item in query.limit(limit).all()]
    return suggestions
```

## 三、前端知识库管理界面

### 1. 知识管理页面

```typescript:frontend/src/pages/knowledge/index.tsx
import { useState, useEffect } from 'react';
import { 
  Layout, 
  Menu, 
  Button, 
  Input, 
  Table, 
  Space, 
  Tag, 
  Dropdown, 
  message,
  Modal,
  Badge
} from 'antd';
import { 
  SearchOutlined,
  PlusOutlined,
  EditOutlined,
  DeleteOutlined,
  MoreOutlined,
  EyeOutlined,
  TagOutlined,
  FileTextOutlined,
  FolderOutlined
} from '@ant-design/icons';
import Link from 'next/link';
import { useRouter } from 'next/router';
import MainLayout from '@/components/layouts/MainLayout';
import { getToken } from '@/utils/auth';

const { Content, Sider } = Layout;

interface Category {
  id: number;
  name: string;
  children?: Category[];
}

interface Tag {
  id: number;
  name: string;
  color: string;
}

interface KnowledgeItem {
  id: number;
  title: string;
  summary: string;
  category_id: number;
  category: { id: number; name: string };
  tags: Tag[];
  status: string;
  view_count: number;
  updated_at: string;
}

const KnowledgeManagement = () => {
  const [categories, setCategories] = useState<Category[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<number | null>(null);
  const [knowledge, setKnowledge] = useState<KnowledgeItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchText, setSearchText] = useState('');
  const router = useRouter();

  useEffect(() => {
    fetchCategories();
    fetchKnowledgeItems();
  }, [selectedCategory]);

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories/tree', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setCategories(data);
      } else {
        message.error('获取分类失败');
      }
    } catch (error) {
      console.error('获取分类失败', error);
      message.error('获取分类失败');
    }
  };

  const fetchKnowledgeItems = async () => {
    setLoading(true);
    try {
      let url = '/api/knowledge';
      const params = new URLSearchParams();
      
      if (selectedCategory) {
        params.append('category_id', selectedCategory.toString());
      }
      
      if (searchText) {
        params.append('q', searchText);
        url = '/api/search';
      }
      
      if (params.toString()) {
        url += `?${params.toString()}`;
      }
      
      const response = await fetch(url, {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setKnowledge(data);
      } else {
        message.error('获取知识条目失败');
      }
    } catch (error) {
      console.error('获取知识条目失败', error);
      message.error('获取知识条目失败');
    } finally {
      setLoading(false);
    }
  };

  const handleSearch = () => {
    fetchKnowledgeItems();
  };

  const handleDelete = async (id: number) => {
    try {
      const response = await fetch(`/api/knowledge/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        message.success('删除成功');
        fetchKnowledgeItems();
      } else {
        message.error('删除失败');
      }
    } catch (error) {
      console.error('删除知识条目失败', error);
      message.error('删除失败');
    }
  };

  const confirmDelete = (id: number, title: string) => {
    Modal.confirm({
      title: '确认删除',
      content: `确定要删除"${title}"吗？此操作不可逆。`,
      okText: '删除',
      okType: 'danger',
      cancelText: '取消',
      onOk() {
        handleDelete(id);
      }
    });
  };

  const renderCategoryMenu = (items: Category[], parentKey = '') => {
    return items.map(item => {
      const key = `${parentKey}${item.id}`;
      if (item.children && item.children

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统设计与开发

## 三、前端知识库管理界面(续)

### 1. 知识管理页面(续)

```typescript:frontend/src/pages/knowledge/index.tsx
  const renderCategoryMenu = (items: Category[], parentKey = '') => {
    return items.map(item => {
      const key = `${parentKey}${item.id}`;
      if (item.children && item.children.length > 0) {
        return {
          key: item.id,
          icon: <FolderOutlined />,
          label: item.name,
          children: renderCategoryMenu(item.children, `${key}-`)
        };
      }
      return {
        key: item.id,
        icon: <FileTextOutlined />,
        label: item.name
      };
    });
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'published':
        return <Badge status="success" text="已发布" />;
      case 'draft':
        return <Badge status="warning" text="草稿" />;
      case 'archived':
        return <Badge status="default" text="已归档" />;
      default:
        return <Badge status="processing" text={status} />;
    }
  };

  const columns = [
    {
      title: '标题',
      dataIndex: 'title',
      key: 'title',
      render: (text: string, record: KnowledgeItem) => (
        <Link href={`/knowledge/${record.id}`}>{text}</Link>
      )
    },
    {
      title: '分类',
      dataIndex: 'category',
      key: 'category',
      render: (category: { name: string }) => category?.name || '-'
    },
    {
      title: '标签',
      key: 'tags',
      dataIndex: 'tags',
      render: (tags: Tag[]) => (
        <>
          {tags && tags.map(tag => (
            <Tag color={tag.color || 'blue'} key={tag.id}>
              {tag.name}
            </Tag>
          ))}
        </>
      ),
    },
    {
      title: '状态',
      dataIndex: 'status',
      key: 'status',
      render: (status: string) => getStatusBadge(status)
    },
    {
      title: '浏览量',
      dataIndex: 'view_count',
      key: 'view_count',
    },
    {
      title: '更新时间',
      dataIndex: 'updated_at',
      key: 'updated_at',
      render: (date: string) => new Date(date).toLocaleString()
    },
    {
      title: '操作',
      key: 'action',
      render: (_, record: KnowledgeItem) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => router.push(`/knowledge/${record.id}`)}
          />
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => router.push(`/knowledge/edit/${record.id}`)}
          />
          <Button 
            type="text" 
            danger
            icon={<DeleteOutlined />} 
            onClick={() => confirmDelete(record.id, record.title)}
          />
        </Space>
      ),
    },
  ];

  return (
    <MainLayout>
      <Layout className="bg-white">
        <Sider width={250} className="bg-white border-r" collapsible={false}>
          <div className="p-4">
            <Button 
              type="primary" 
              icon={<PlusOutlined />} 
              block
              onClick={() => router.push('/knowledge/create')}
            >
              创建知识条目
            </Button>
          </div>
          <Menu
            mode="inline"
            selectedKeys={selectedCategory ? [selectedCategory.toString()] : []}
            style={{ height: '100%' }}
            items={[
              {
                key: 'all',
                icon: <FolderOutlined />,
                label: '所有知识',
                onClick: () => setSelectedCategory(null)
              },
              ...renderCategoryMenu(categories)
            ]}
            onSelect={({ key }) => {
              if (key === 'all') {
                setSelectedCategory(null);
              } else {
                setSelectedCategory(parseInt(key.toString()));
              }
            }}
          />
        </Sider>
        <Content className="p-6">
          <div className="flex justify-between items-center mb-4">
            <h1 className="text-2xl font-bold">知识库管理</h1>
            <div className="flex">
              <Input
                placeholder="搜索知识..."
                value={searchText}
                onChange={(e) => setSearchText(e.target.value)}
                style={{ width: 300 }}
                onPressEnter={handleSearch}
              />
              <Button
                type="primary"
                icon={<SearchOutlined />}
                onClick={handleSearch}
                className="ml-2"
              >
                搜索
              </Button>
            </div>
          </div>
          
          <Table
            columns={columns}
            dataSource={knowledge}
            rowKey="id"
            loading={loading}
            pagination={{ pageSize: 10 }}
          />
        </Content>
      </Layout>
    </MainLayout>
  );
};

export default KnowledgeManagement;
```

### 2. 知识创建/编辑页面

```typescript:frontend/src/pages/knowledge/create.tsx
import { useState, useEffect } from 'react';
import { 
  Form, 
  Input, 
  Button, 
  Select, 
  Switch, 
  Upload, 
  message, 
  Card,
  Divider,
  TreeSelect
} from 'antd';
import { 
  UploadOutlined, 
  SaveOutlined, 
  SendOutlined,
  LeftOutlined
} from '@ant-design/icons';
import { useRouter } from 'next/router';
import MainLayout from '@/components/layouts/MainLayout';
import dynamic from 'next/dynamic';
import { getToken } from '@/utils/auth';

// 动态导入富文本编辑器，避免服务端渲染问题
const Editor = dynamic(() => import('@/components/features/Editor'), { ssr: false });

const { Option } = Select;

interface Category {
  id: number;
  name: string;
  children?: Category[];
}

interface Tag {
  id: number;
  name: string;
  color: string;
}

const KnowledgeCreate = () => {
  const [form] = Form.useForm();
  const [categories, setCategories] = useState<Category[]>([]);
  const [tags, setTags] = useState<Tag[]>([]);
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  useEffect(() => {
    fetchCategories();
    fetchTags();
  }, []);

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories/tree', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setCategories(data);
      } else {
        message.error('获取分类失败');
      }
    } catch (error) {
      console.error('获取分类失败', error);
      message.error('获取分类失败');
    }
  };

  const fetchTags = async () => {
    try {
      const response = await fetch('/api/tags', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setTags(data);
      } else {
        message.error('获取标签失败');
      }
    } catch (error) {
      console.error('获取标签失败', error);
      message.error('获取标签失败');
    }
  };

  const renderTreeNodes = (data: Category[]) => {
    return data.map(item => {
      if (item.children && item.children.length) {
        return {
          title: item.name,
          value: item.id,
          key: item.id,
          children: renderTreeNodes(item.children)
        };
      }
      return {
        title: item.name,
        value: item.id,
        key: item.id
      };
    });
  };
  
  const handleSave = async (status: string) => {
    try {
      const values = await form.validateFields();
      setLoading(true);
      
      // 提交表单数据
      const knowledgeData = {
        ...values,
        content: content,
        status: status,
        organization_id: 0  // 后端会根据用户自动填充组织ID
      };
      
      const response = await fetch('/api/knowledge', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(knowledgeData)
      });
      
      if (response.ok) {
        const data = await response.json();
        message.success('保存成功');
        router.push(`/knowledge/${data.id}`);
      } else {
        const error = await response.json();
        throw new Error(error.detail || '保存失败');
      }
    } catch (error) {
      console.error('保存知识条目失败', error);
      message.error(error instanceof Error ? error.message : '保存失败');
    } finally {
      setLoading(false);
    }
  };

  return (
    <MainLayout>
      <div className="p-6 bg-white">
        <div className="mb-4">
          <Button 
            icon={<LeftOutlined />} 
            onClick={() => router.back()}
          >
            返回
          </Button>
          <h1 className="text-2xl font-bold mt-2">创建知识条目</h1>
        </div>
        
        <Form
          form={form}
          layout="vertical"
          initialValues={{
            is_public: false,
          }}
        >
          <div className="flex space-x-6">
            <div className="flex-1">
              <Card title="内容编辑" className="mb-6">
                <Form.Item
                  name="title"
                  label="标题"
                  rules={[{ required: true, message: '请输入标题' }]}
                >
                  <Input placeholder="请输入标题" />
                </Form.Item>
                
                <Form.Item
                  label="内容"
                  required
                >
                  <Editor
                    value={content}
                    onChange={setContent}
                    placeholder="请输入知识条目内容..."
                  />
                </Form.Item>
                
                <Form.Item
                  name="summary"
                  label="摘要"
                >
                  <Input.TextArea
                    rows={3}
                    placeholder="请输入摘要，如不填写将自动从内容中提取"
                  />
                </Form.Item>
              </Card>
              
              <Card title="附件" className="mb-6">
                <Upload
                  name="file"
                  action="/api/uploads"
                  headers={{
                    Authorization: `Bearer ${getToken()}`
                  }}
                  onChange={info => {
                    if (info.file.status === 'done') {
                      message.success(`${info.file.name} 上传成功`);
                    } else if (info.file.status === 'error') {
                      message.error(`${info.file.name} 上传失败`);
                    }
                  }}
                >
                  <Button icon={<UploadOutlined />}>上传附件</Button>
                </Upload>
              </Card>
            </div>
            
            <div className="w-80">
              <Card title="设置" className="mb-6">
                <Form.Item
                  name="category_id"
                  label="分类"
                >
                  <TreeSelect
                    placeholder="请选择分类"
                    treeData={renderTreeNodes(categories)}
                    treeDefaultExpandAll
                  />
                </Form.Item>
                
                <Form.Item
                  name="tag_ids"
                  label="标签"
                >
                  <Select
                    mode="multiple"
                    placeholder="请选择标签"
                    optionLabelProp="label"
                  >
                    {tags.map(tag => (
                      <Option key={tag.id} value={tag.id} label={tag.name}>
                        <div className="flex items-center">
                          <span
                            className="w-3 h-3 rounded-full mr-2"
                            style={{ backgroundColor: tag.color || '#1890ff' }}
                          />
                          {tag.name}
                        </div>
                      </Option>
                    ))}
                  </Select>
                </Form.Item>
                
                <Form.Item
                  name="is_public"
                  label="公开可见"
                  valuePropName="checked"
                >
                  <Switch />
                </Form.Item>
              </Card>
              
              <div className="flex space-x-2">
                <Button
                  type="primary"
                  icon={<SaveOutlined />}
                  onClick={() => handleSave('draft')}
                  loading={loading}
                  block
                >
                  保存草稿
                </Button>
                <Button
                  type="primary"
                  icon={<SendOutlined />}
                  onClick={() => handleSave('published')}
                  loading={loading}
                  block
                >
                  发布
                </Button>
              </div>
            </div>
          </div>
        </Form>
      </div>
    </MainLayout>
  );
};

export default KnowledgeCreate;
```

### 3. 知识条目查看页面

```typescript:frontend/src/pages/knowledge/[id].tsx
import { useState, useEffect } from 'react';
import { 
  Button, 
  Tag, 
  Space, 
  Skeleton, 
  message, 
  Divider, 
  Card,
  List,
  Typography,
  Breadcrumb
} from 'antd';
import { 
  EditOutlined, 
  DeleteOutlined, 
  EyeOutlined, 
  ClockCircleOutlined,
  UserOutlined,
  TagOutlined,
  DownloadOutlined,
  LeftOutlined,
  FolderOutlined
} from '@ant-design/icons';
import { useRouter } from 'next/router';
import MainLayout from '@/components/layouts/MainLayout';
import { getToken } from '@/utils/auth';
import Link from 'next/link';

const { Title, Paragraph, Text } = Typography;

interface Tag {
  id: number;
  name: string;
  color: string;
}

interface Category {
  id: number;
  name: string;
}

interface Attachment {
  id: number;
  filename: string;
  file_path: string;
  file_size: number;
  file_type: string;
}

interface KnowledgeDetail {
  id: number;
  title: string;
  content: string;
  summary: string;
  category_id: number;
  category: Category;
  tags: Tag[];
  status: string;
  view_count: number;
  is_public: boolean;
  creator: {
    id: number;
    username: string;
    full_name: string;
  };
  last_editor: {
    id: number;
    username: string;
    full_name: string;
  } | null;
  attachments: Attachment[];
  created_at: string;
  updated_at: string;
}

const KnowledgeDetailPage = () => {
  const [knowledge, setKnowledge] = useState<KnowledgeDetail | null>(null);
  const [loading, setLoading] = useState(true);
  const [relatedItems, setRelatedItems] = useState([]);
  const router = useRouter();
  const { id } = router.query;

  useEffect(() => {
    if (id) {
      fetchKnowledgeDetail(id as string);
    }
  }, [id]);

  const fetchKnowledgeDetail = async (knowledgeId: string) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/knowledge/${knowledgeId}`, {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setKnowledge(data);
        // 假设获取相关知识条目
        fetchRelatedItems(data.category_id, data.id);
      } else {
        const error = await response.json();
        throw new Error(error.detail || '获取详情失败');
      }
    } catch (error) {
      console.error('获取知识条目详情失败', error);
      message.error(error instanceof Error ? error.message : '获取详情失败');
    } finally {
      setLoading(false);
    }
  };

  const fetchRelatedItems = async (categoryId: number, currentId: number) => {
    try {
      const response = await fetch(`/api/knowledge?category_id=${categoryId}&limit=5`, {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        // 过滤掉当前条目
        setRelatedItems(data.filter((item: any) => item.id !== currentId).slice(0, 4));
      }
    } catch (error) {
      console.error('获取相关知识条目失败', error);
    }
  };

  const handleDelete = async () => {
    if (!knowledge) return;
    
    try {
      const response = await fetch(`/api/knowledge/${knowledge.id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        message.success('删除成功');
        router.push('/knowledge');
      } else {
        const error = await response.json();
        throw new Error(error.detail || '删除失败');
      }
    } catch (error) {
      console.error('删除知识条目失败', error);
      message.error(error instanceof Error ? error.message : '删除失败');
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return bytes + ' B';
    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    else return (bytes / 1048576).toFixed(1) + ' MB';
  };

  const downloadAttachment = (attachment: Attachment) => {
    window.open(`/api/attachments/${attachment.id}/download`, '_blank');
  };

  if (loading) {
    return (
      <MainLayout>
        <div className="p-6 bg-white">
          <Skeleton active />
          <Skeleton active />
        </div>
      </MainLayout>
    );
  }

  if (!knowledge) {
    return (
      <MainLayout>
        <div className="p-6 bg-white text-center">
          <h1 className="text-xl">知识条目不存在或已被删除</h1>
          <Button onClick={() => router.push('/knowledge')} className="mt-4">
            返回知识库
          </Button>
        </div>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <div className="p-6 bg-white">
        <div className="mb-4">
          <Breadcrumb>
            <Breadcrumb.Item>
              <Link href="/knowledge">知识库</Link>
            </Breadcrumb.Item>
            {knowledge.category && (
              <Breadcrumb.Item>
                <Link href={`/knowledge?category_id=${knowledge.category.id}`}>
                  {knowledge.category.name}
                </Link>
              </Breadcrumb.Item>
            )}
            <Breadcrumb.Item>{knowledge.title}</Breadcrumb.Item>
          </Breadcrumb>

          <div className="flex justify-between items-center mt-4">
            <Button icon={<LeftOutlined />} onClick={() => router.back()}>
              返回
            </Button>
            <Space>
              <Button 
                type="primary" 
                icon={<EditOutlined />}
                onClick={() => router.push(`/knowledge/edit/${knowledge.id}`)}
              >
                编辑
              </Button>
              <Button 
                danger 
                icon={<DeleteOutlined />}
                onClick={handleDelete}
              >
                删除
              </Button>
            </Space>
          </div>
        </div>

        <div className="flex space-x-6">
          <div className="flex-1">
            <Title level={2}>{knowledge.title}</Title>
            
            <div className="mb-4 flex items-center text-gray-500">
              <Space className="mr-6">
                <UserOutlined />
                <span>{knowledge.creator.full_name || knowledge.creator.username}</span>
              </Space>
              
              <Space className="mr-6">
                <ClockCircleOutlined />
                <span>创建于 {new Date(knowledge.created_at).toLocaleString()}</span>
              </Space>
              
              <Space>
                <EyeOutlined />
                <span>{knowledge.view_count} 次浏览</span>
              </Space>
            </div>
            
            <div className="mb-6">
              {knowledge.tags.map(tag => (
                <Tag color={tag.color || 'blue'} key={tag.id}>
                  {tag.name}
                </Tag>
              ))}
            </div>
            
            {knowledge.summary && (
              <div className="bg-gray-50 p-4 rounded mb-6">
                <Paragraph className="text-gray-600">{knowledge.summary}</Paragraph>
              </div>
            )}
            
            <Divider />
            
            <div className="knowledge-content mb-6">
              <div dangerouslySetInnerHTML={{ __html: knowledge.content }} />
            </div>
            
            {knowledge.attachments.length > 0 && (
              <Card title="附件" className="mb-6">
                <List
                  itemLayout="horizontal"
                  dataSource={knowledge.attachments}
                  renderItem={item => (
                    <List.Item
                      actions={[
                        <Button 
                          key="download" 
                          type="link" 
                          icon={<DownloadOutlined />}
                          onClick={() => downloadAttachment(item)}
                        >
                          下载
                        </Button>
                      ]}
                    >
                      <List.Item.Meta
                        title={item.filename}
                        description={`${item.file_type} · ${formatFileSize(item.file_size)}`}
                      />
                    </List.Item>
                  )}
                />
              </Card>
            )}
          </div>
          
          <div className="w-80">
            <Card title="分类" className="mb-6">
              <div className="flex items-center">
                <FolderOutlined className="mr-2" />
                {knowledge.category ? (
                  <Link href={`/knowledge?category_id=${knowledge.category.id}`}>
                    {knowledge.category.name}
                  </Link>
                ) : (
                  <span className="text-gray-500">未分类</span>
                )}
              </div>
            </Card>
            
            {relatedItems.length > 0 && (
              <Card title="相关知识" className="mb-6">
                <List
                  itemLayout="vertical"
                  dataSource={relatedItems}
                  renderItem={(item: any) => (
                    <List.Item>
                      <Link href={`/knowledge/${item.id}`}>
                        {item.title}
                      </Link>
                    </List.Item>
                  )}
                />
              </Card>
            )}
            
            <Card title="操作记录">
              <div className="mb-2">
                <Text type="secondary">创建者：</Text>
                <Text>{knowledge.creator.full_name || knowledge.creator.username}</Text>
              </div>
              <div className="mb-2">
                <Text type="secondary">创建时间：</Text>
                <Text>{new Date(knowledge.created_at).toLocaleString()}</Text>
              </div>
              {knowledge.last_editor && (
                <>
                  <div className="mb-2">
                    <Text type="secondary">最后编辑：</Text>
                    <Text>{knowledge.last_editor.full_name || knowledge.last_editor.username}</Text>
                  </div>
                  <div>
                    <Text type="secondary">更新时间：</Text>
                    <Text>{new Date(knowledge.updated_at).toLocaleString()}</Text>
                  </div>
                </>
              )}
            </Card>
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default KnowledgeDetailPage;
```

### 4. 知识编辑页面

```typescript:frontend/src/pages/knowledge/edit/[id].tsx
import { useState, useEffect } from 'react';
import { 
  Form, 
  Input, 
  Button, 
  Select, 
  Switch, 
  Upload, 
  message, 
  Card,
  Divider,
  TreeSelect,
  Skeleton,
  List
} from 'antd';
import { 
  UploadOutlined, 
  SaveOutlined, 
  SendOutlined,
  LeftOutlined,
  DeleteOutlined
} from '@ant-design/icons';
import { useRouter } from 'next/router';
import MainLayout from '@/components/layouts/MainLayout';
import dynamic from 'next/dynamic';
import { getToken } from '@/utils/auth';

// 动态导入富文本编辑器，避免服务端渲染问题
const Editor = dynamic(() => import('@/components/features/Editor'), { ssr: false });

const { Option } = Select;

interface Category {
  id: number;
  name: string;
  children?: Category[];
}

interface Tag {
  id: number;
  name: string;
  color: string;
}

interface Attachment {
  id: number;
  filename: string;
  file_size: number;
  file_type: string;
}

interface KnowledgeDetail {
  id: number;
  title: string;
  content: string;
  summary: string;
  category_id: number;
  tag_ids: number[];
  tags: Tag[];
  status: string;
  is_public: boolean;
  attachments: Attachment[];
}

const KnowledgeEdit = () => {
  const [form] = Form.useForm();
  const [categories, setCategories] = useState<Category[]>([]);
  const [tags, setTags] = useState<Tag[]>([]);
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(true);
  const [saveLoading, setSaveLoading] = useState(false);
  const [knowledge, setKnowledge] = useState<KnowledgeDetail | null>(null);
  const router = useRouter();
  const { id } = router.query;

  useEffect(() => {
    if (id) {
      fetchKnowledgeDetail(id as string);
      fetchCategories();
      fetchTags();
    }
  }, [id]);

  const fetchKnowledgeDetail = async (knowledgeId: string) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/knowledge/${knowledgeId}`, {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setKnowledge(data);
        setContent(data.content);
        form.setFieldsValue({
          title: data.title,
          summary: data.summary,
          category_id: data.category_id,
          tag_ids: data.tags.map(tag => tag.id),
          is_public: data.is_public,
          status: data.status
        });
      } else {
        const error = await response.json();
        throw new Error(error.detail || '获取详情失败');
      }
    } catch (error) {
      console.error('获取知识条目详情失败', error);
      message.error(error instanceof Error ? error.message : '获取详情失败');
    } finally {
      setLoading(false);
    }
  };

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories/tree', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setCategories(data);
      } else {
        message.error('获取分类失败');
      }
    } catch (error) {
      console.error('获取分类失败', error);
      message.error('获取分类失败');
    }
  };

  const fetchTags = async () => {
    try {
      const response = await fetch('/api/tags', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setTags(data);
      } else {
        message.error('获取标签失败');
      }
    } catch (error) {
      console.error('获取标签失败', error);
      message.error('获取标签失败');
    }
  };

  const renderTreeNodes = (data: Category[]) => {
    return data.map(item => {
      if (item.children && item.children.length) {
        return {
          title: item.name,
          value: item.id,
          key: item.id,
          children: renderTreeNodes(item.children)
        };
      }
      return {
        title: item.name,
        value: item.id,
        key: item.id
      };
    });
  };
  
  const handleSave = async (newStatus?: string) => {
    if (!knowledge) return;
    
    try {
      const values = await form.validateFields();
      setSaveLoading(true);
      
      const status = newStatus || values.status || knowledge.status;
      
      // 提交表单数据
      const knowledgeData = {
        ...values,
        content: content,
        status: status
      };
      
      const response = await fetch(`/api/knowledge/${knowledge.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(knowledgeData)
      });
      
      if (response.ok) {
        message.success('保存成功');
        if (newStatus === 'published') {
          router.push(`/knowledge/${knowledge.id}`);
        }
      } else {
        const error = await response.json();
        throw new Error(error.detail || '保存失败');
      }
    } catch (error) {
      console.error('保存知识条目失败', error);
      message.error(error instanceof Error ? error.message : '保存失败');
    } finally {
      setSaveLoading(false);
    }
  };

  const deleteAttachment = async (attachmentId: number) => {
    try {
      const response = await fetch(`/api/attachments/${attachmentId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        message.success('删除附件成功');
        // 更新附件列表
        if (knowledge) {
          setKnowledge({
            ...knowledge,
            attachments: knowledge.attachments.filter(a => a.id !== attachmentId)
          });
        }
      } else {
        throw new Error('删除附件失败');
      }
    } catch (error) {
      console.error('删除附件失败', error);
      message.error('删除附件失败');
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return bytes + ' B';
    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    else return (bytes / 1048576).toFixed(1) + ' MB';
  };

  if (loading) {
    return (
      <MainLayout>
        <div className="p-6 bg-white">
          <Skeleton active />
          <Skeleton active />
        </div>
      </MainLayout>
    );
  }

  if (!knowledge) {
    return (
      <MainLayout>
        <div className="p-6 bg-white text-center">
          <h1 className="text-xl">知识条目不存在或已被删除</h1>
          <Button onClick={() => router.push('/knowledge')} className="mt-4">
            返回知识库
          </Button>
        </div>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <div className="p-6 bg-white">
        <div className="mb-4">
          <Button 
            icon={<LeftOutlined />} 
            onClick={() => router.back()}
          >
            返回
          </Button>
          <h1 className="text-2xl font-bold mt-2">编辑知识条目</h1>
        </div>
        
        <Form
          form={form}
          layout="vertical"
        >
          <div className="flex space-x-6">
            <div className="flex-1">
              <Card title="内容编辑" className="mb-6">
                <Form.Item
                  name="title"
                  label="标题"
                  rules={[{ required: true, message: '请输入标题' }]}
                >
                  <Input placeholder="请输入标题" />
                </Form.Item>
                
                <Form.Item
                  label="内容"
                  required
                >
                  <Editor
                    value={content}
                    onChange={setContent}
                    placeholder="请输入知识条目内容..."
                  />
                </Form.Item>
                
                <Form.Item
                  name="summary"
                  label="摘要"
                >
                  <Input.TextArea
                    rows={3}
                    placeholder="请输入摘要，如不填写将自动从内容中提取"
                  />
                </Form.Item>
              </Card>
              
              <Card title="附件" className="mb-6">
                {knowledge.attachments.length > 0 && (
                  <List
                    className="mb-4"
                    itemLayout="horizontal"
                    dataSource={knowledge.attachments}
                    renderItem={item => (
                      <List.Item
                        actions={[
                          <Button 
                            key="delete" 
                            type="text" 
                            danger 
                            icon={<DeleteOutlined />}
                            onClick={() => deleteAttachment(item.id)}
                          >
                            删除
                          </Button>
                        ]}
                      >
                        <List.Item.Meta
                          title={item.filename}
                          description={`${item.file_type} · ${formatFileSize(item.file_size)}`}
                        />
                      </List.Item>
                    )}
                  />
                )}
                
                <Upload
                  name="file"
                  action={`/api/knowledge/${knowledge.id}/attachments`}
                  headers={{
                    Authorization: `Bearer ${getToken()}`
                  }}
                  onChange={info => {
                    if (info.file.status === 'done') {
                      message.success(`${info.file.name} 上传成功`);
                      // 刷新附件列表
                      fetchKnowledgeDetail(knowledge.id.toString());
                    } else if (info.file.status === 'error') {
                      message.error(`${info.file.name} 上传失败`);
                    }
                  }}
                >
                  <Button icon={<UploadOutlined />}>上传附件</Button>
                </Upload>
              </Card>
            </div>
            
            <div className="w-80">
              <Card title="设置" className="mb-6">
                <Form.Item
                  name="status"
                  label="状态"
                  initialValue={knowledge.status}
                >
                  <Select>
                    <Option value="draft">草稿</Option>
                    <Option value="published">已发布</Option>
                    <Option value="archived">已归档</Option>
                  </Select>
                </Form.Item>
                
                <Form.Item
                  name="category_id"
                  label="分类"
                >
                  <TreeSelect
                    placeholder="请选择分类"
                    treeData={renderTreeNodes(categories)}
                    treeDefaultExpandAll
                  />
                </Form.Item>
                
                <Form.

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统设计与开发

## 三、前端知识库管理界面(续)

### 4. 知识编辑页面(续)

```typescript:frontend/src/pages/knowledge/edit/[id].tsx
                <Form.Item
                  name="tag_ids"
                  label="标签"
                >
                  <Select
                    mode="multiple"
                    placeholder="请选择标签"
                    optionLabelProp="label"
                  >
                    {tags.map(tag => (
                      <Option key={tag.id} value={tag.id} label={tag.name}>
                        <div className="flex items-center">
                          <span
                            className="w-3 h-3 rounded-full mr-2"
                            style={{ backgroundColor: tag.color || '#1890ff' }}
                          />
                          {tag.name}
                        </div>
                      </Option>
                    ))}
                  </Select>
                </Form.Item>
                
                <Form.Item
                  name="is_public"
                  label="公开可见"
                  valuePropName="checked"
                >
                  <Switch />
                </Form.Item>
              </Card>
              
              <div className="flex space-x-2">
                <Button
                  type="primary"
                  icon={<SaveOutlined />}
                  onClick={() => handleSave('draft')}
                  loading={saveLoading}
                  block
                >
                  保存草稿
                </Button>
                <Button
                  type="primary"
                  icon={<SendOutlined />}
                  onClick={() => handleSave('published')}
                  loading={saveLoading}
                  block
                >
                  发布
                </Button>
              </div>
            </div>
          </div>
        </Form>
      </div>
    </MainLayout>
  );
};

export default KnowledgeEdit;
```

### 5. 标签管理页面

```typescript:frontend/src/pages/admin/knowledge-config/tags.tsx
import { useState, useEffect } from 'react';
import { Table, Button, Space, Modal, Form, Input, ColorPicker, message, Popconfirm } from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

interface Tag {
  id: number;
  name: string;
  color: string;
  created_at: string;
}

const TagManagement = () => {
  const [tags, setTags] = useState<Tag[]>([]);
  const [loading, setLoading] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [form] = Form.useForm();
  const [editingId, setEditingId] = useState<number | null>(null);

  // 获取标签列表
  const fetchTags = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/tags', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      if (!response.ok) throw new Error('获取标签列表失败');
      const data = await response.json();
      setTags(data);
    } catch (error) {
      message.error('获取标签列表失败');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTags();
  }, []);

  // 添加或更新标签
  const handleSubmit = async (values: any) => {
    try {
      const url = editingId 
        ? `/api/tags/${editingId}` 
        : '/api/tags';
      
      const method = editingId ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || '操作失败');
      }
      
      message.success(editingId ? '更新成功' : '添加成功');
      setModalVisible(false);
      form.resetFields();
      setEditingId(null);
      fetchTags();
    } catch (error) {
      message.error(error instanceof Error ? error.message : '操作失败');
      console.error(error);
    }
  };

  // 删除标签
  const handleDelete = async (id: number) => {
    try {
      const response = await fetch(`/api/tags/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || '删除失败');
      }
      
      message.success('删除成功');
      fetchTags();
    } catch (error) {
      message.error(error instanceof Error ? error.message : '删除失败');
      console.error(error);
    }
  };

  // 编辑标签
  const handleEdit = (record: Tag) => {
    setEditingId(record.id);
    form.setFieldsValue({
      name: record.name,
      color: record.color,
    });
    setModalVisible(true);
  };

  const columns = [
    {
      title: '标签名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: '颜色',
      dataIndex: 'color',
      key: 'color',
      render: (color: string) => (
        <div 
          className="w-6 h-6 rounded"
          style={{ backgroundColor: color || '#1890ff' }}
        />
      )
    },
    {
      title: '创建时间',
      dataIndex: 'created_at',
      key: 'created_at',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: '操作',
      key: 'action',
      render: (_: any, record: Tag) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => handleEdit(record)}
          >
            编辑
          </Button>
          <Popconfirm
            title="确定要删除这个标签吗?"
            onConfirm={() => handleDelete(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="text" danger icon={<DeleteOutlined />}>
              删除
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <AdminLayout>
      <div className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-2xl font-bold">标签管理</h1>
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => {
              setEditingId(null);
              form.resetFields();
              setModalVisible(true);
            }}
          >
            添加标签
          </Button>
        </div>
        
        <Table 
          columns={columns} 
          dataSource={tags} 
          rowKey="id"
          loading={loading}
          pagination={{ pageSize: 10 }}
        />
        
        <Modal
          title={editingId ? "编辑标签" : "添加标签"}
          open={modalVisible}
          onCancel={() => setModalVisible(false)}
          footer={null}
        >
          <Form
            form={form}
            layout="vertical"
            onFinish={handleSubmit}
          >
            <Form.Item
              name="name"
              label="标签名称"
              rules={[{ required: true, message: '请输入标签名称' }]}
            >
              <Input placeholder="请输入标签名称" />
            </Form.Item>
            
            <Form.Item
              name="color"
              label="标签颜色"
              initialValue="#1890ff"
            >
              <ColorPicker />
            </Form.Item>
            
            <Form.Item className="mb-0 text-right">
              <Space>
                <Button onClick={() => setModalVisible(false)}>取消</Button>
                <Button type="primary" htmlType="submit">
                  {editingId ? '更新' : '添加'}
                </Button>
              </Space>
            </Form.Item>
          </Form>
        </Modal>
      </div>
    </AdminLayout>
  );
};

export default TagManagement;
```

### 6. 分类管理页面

```typescript:frontend/src/pages/admin/knowledge-config/categories.tsx
import { useState, useEffect } from 'react';
import { Table, Button, Space, Modal, Form, Input, TreeSelect, message, Popconfirm } from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';
import AdminLayout from '@/components/layouts/AdminLayout';
import { getToken } from '@/utils/auth';

interface Category {
  id: number;
  name: string;
  description: string;
  parent_id: number | null;
  created_at: string;
  updated_at: string;
}

const CategoryManagement = () => {
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [form] = Form.useForm();
  const [editingId, setEditingId] = useState<number | null>(null);

  // 获取分类列表
  const fetchCategories = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/categories', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      if (!response.ok) throw new Error('获取分类列表失败');
      const data = await response.json();
      setCategories(data);
    } catch (error) {
      message.error('获取分类列表失败');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  // 添加或更新分类
  const handleSubmit = async (values: any) => {
    try {
      const url = editingId 
        ? `/api/categories/${editingId}` 
        : '/api/categories';
      
      const method = editingId ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify(values),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || '操作失败');
      }
      
      message.success(editingId ? '更新成功' : '添加成功');
      setModalVisible(false);
      form.resetFields();
      setEditingId(null);
      fetchCategories();
    } catch (error) {
      message.error(error instanceof Error ? error.message : '操作失败');
      console.error(error);
    }
  };

  // 删除分类
  const handleDelete = async (id: number) => {
    try {
      const response = await fetch(`/api/categories/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || '删除失败');
      }
      
      message.success('删除成功');
      fetchCategories();
    } catch (error) {
      message.error(error instanceof Error ? error.message : '删除失败');
      console.error(error);
    }
  };

  // 编辑分类
  const handleEdit = (record: Category) => {
    setEditingId(record.id);
    form.setFieldsValue({
      name: record.name,
      description: record.description,
      parent_id: record.parent_id,
    });
    setModalVisible(true);
  };

  // 构建树形数据
  const buildTreeData = (data: Category[]) => {
    const result: any[] = [];
    const map = new Map();
    
    // 先创建所有节点的映射
    data.forEach(item => {
      map.set(item.id, { 
        title: item.name, 
        value: item.id, 
        key: item.id,
        children: [] 
      });
    });
    
    // 构建树结构
    data.forEach(item => {
      const node = map.get(item.id);
      if (item.parent_id && map.has(item.parent_id)) {
        // 如果有父节点，则添加到父节点的children
        const parent = map.get(item.parent_id);
        parent.children.push(node);
      } else {
        // 没有父节点的作为根节点
        result.push(node);
      }
    });
    
    return result;
  };

  // 获取父分类名称
  const getParentName = (parentId: number | null) => {
    if (!parentId) return '-';
    const parent = categories.find(c => c.id === parentId);
    return parent ? parent.name : '-';
  };

  const columns = [
    {
      title: '分类名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: '描述',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: '父分类',
      dataIndex: 'parent_id',
      key: 'parent_id',
      render: (parentId: number | null) => getParentName(parentId),
    },
    {
      title: '创建时间',
      dataIndex: 'created_at',
      key: 'created_at',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: '操作',
      key: 'action',
      render: (_: any, record: Category) => (
        <Space size="middle">
          <Button 
            type="text" 
            icon={<EditOutlined />} 
            onClick={() => handleEdit(record)}
          >
            编辑
          </Button>
          <Popconfirm
            title="确定要删除这个分类吗?"
            onConfirm={() => handleDelete(record.id)}
            okText="确定"
            cancelText="取消"
          >
            <Button type="text" danger icon={<DeleteOutlined />}>
              删除
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <AdminLayout>
      <div className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-2xl font-bold">分类管理</h1>
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => {
              setEditingId(null);
              form.resetFields();
              setModalVisible(true);
            }}
          >
            添加分类
          </Button>
        </div>
        
        <Table 
          columns={columns} 
          dataSource={categories} 
          rowKey="id"
          loading={loading}
          pagination={{ pageSize: 10 }}
        />
        
        <Modal
          title={editingId ? "编辑分类" : "添加分类"}
          open={modalVisible}
          onCancel={() => setModalVisible(false)}
          footer={null}
        >
          <Form
            form={form}
            layout="vertical"
            onFinish={handleSubmit}
          >
            <Form.Item
              name="name"
              label="分类名称"
              rules={[{ required: true, message: '请输入分类名称' }]}
            >
              <Input placeholder="请输入分类名称" />
            </Form.Item>
            
            <Form.Item
              name="description"
              label="描述"
            >
              <Input.TextArea rows={3} placeholder="请输入分类描述" />
            </Form.Item>
            
            <Form.Item
              name="parent_id"
              label="父分类"
            >
              <TreeSelect
                placeholder="请选择父分类（可选）"
                treeData={buildTreeData(categories)}
                allowClear
                treeDefaultExpandAll
                disabled={editingId ? categories.some(c => c.parent_id === editingId) : false}
              />
            </Form.Item>
            
            <Form.Item className="mb-0 text-right">
              <Space>
                <Button onClick={() => setModalVisible(false)}>取消</Button>
                <Button type="primary" htmlType="submit">
                  {editingId ? '更新' : '添加'}
                </Button>
              </Space>
            </Form.Item>
          </Form>
        </Modal>
      </div>
    </AdminLayout>
  );
};

export default CategoryManagement;
```

## 四、智能问答系统实现

### 1. 后端问答API实现

```python:backend/app/models/chat.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base_class import Base

class Chat(Base):
    """聊天会话模型"""
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), index=True, nullable=False)
    
    # 关系
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    user = relationship("User", back_populates="chats")
    
    messages = relationship("ChatMessage", back_populates="chat", cascade="all, delete-orphan")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class ChatMessage(Base):
    """聊天消息模型"""
    id = Column(Integer, primary_key=True, index=True)
    role = Column(String(20), nullable=False)  # user, assistant, system
    content = Column(Text, nullable=False)
    
    # 追加信息
    knowledge_sources = Column(Text, nullable=True)  # 引用的知识来源，JSON格式
    tokens = Column(Integer, nullable=True)  # 令牌数量
    
    # 关系
    chat_id = Column(Integer, ForeignKey("chat.id"), nullable=False)
    chat = relationship("Chat", back_populates="messages")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

```python:backend/app/schemas/chat.py
from typing import Optional, List, Any, Dict
from datetime import datetime
from pydantic import BaseModel

# 聊天消息模型
class ChatMessageBase(BaseModel):
    role: str
    content: str
    knowledge_sources: Optional[str] = None
    tokens: Optional[int] = None

class ChatMessageCreate(ChatMessageBase):
    chat_id: int

class ChatMessageInDBBase(ChatMessageBase):
    id: int
    chat_id: int
    created_at: datetime

    class Config:
        orm_mode = True

class ChatMessage(ChatMessageInDBBase):
    pass

# 聊天会话模型
class ChatBase(BaseModel):
    title: str

class ChatCreate(ChatBase):
    pass

class ChatUpdate(BaseModel):
    title: Optional[str] = None

class ChatInDBBase(ChatBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class Chat(ChatInDBBase):
    messages: List[ChatMessage] = []

# 创建聊天请求
class ChatCompletionRequest(BaseModel):
    chat_id: Optional[int] = None
    message: str
    stream: Optional[bool] = False

# 聊天回复响应
class ChatCompletionResponse(BaseModel):
    id: str
    message: ChatMessageBase
    chat_id: int
    created_at: datetime
    knowledge_sources: Optional[List[Dict[str, Any]]] = None
```

```python:backend/app/api/api_v1/endpoints/chat.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, BackgroundTasks
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session
import uuid
from datetime import datetime
import json

from app import crud, models, schemas
from app.api import deps
from app.services.knowledge_search import search_knowledge
from app.services.llm_service import get_llm_response

router = APIRouter()

@router.get("/", response_model=List[schemas.Chat])
def read_chats(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取用户的聊天会话列表。
    """
    chats = crud.chat.get_multi_by_user(
        db, user_id=current_user.id, skip=skip, limit=limit
    )
    return chats

@router.post("/", response_model=schemas.Chat)
def create_chat(
    *,
    db: Session = Depends(deps.get_db),
    chat_in: schemas.ChatCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新的聊天会话。
    """
    chat = crud.chat.create_with_user(
        db=db, obj_in=chat_in, user_id=current_user.id
    )
    return chat

@router.get("/{id}", response_model=schemas.Chat)
def read_chat(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取聊天会话详情，包括所有消息。
    """
    chat = crud.chat.get(db=db, id=id)
    if not chat:
        raise HTTPException(status_code=404, detail="聊天会话不存在")
    if chat.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="无权访问此聊天会话")
    return chat

@router.delete("/{id}", response_model=schemas.Chat)
def delete_chat(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除聊天会话。
    """
    chat = crud.chat.get(db=db, id=id)
    if not chat:
        raise HTTPException(status_code=404, detail="聊天会话不存在")
    if chat.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="无权删除此聊天会话")
    chat = crud.chat.remove(db=db, id=id)
    return chat

@router.post("/completion", response_model=schemas.ChatCompletionResponse)
async def chat_completion(
    *,
    db: Session = Depends(deps.get_db),
    request: schemas.ChatCompletionRequest,
    background_tasks: BackgroundTasks,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    发送消息并获取AI回复。
    """
    # 检查或创建聊天会话
    chat_id = request.chat_id
    if chat_id:
        chat = crud.chat.get(db=db, id=chat_id)
        if not chat:
            raise HTTPException(status_code=404, detail="聊天会话不存在")
        if chat.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="无权访问此聊天会话")
    else:
        # 创建新的聊天会话，使用用户消息的前20个字符作为标题
        title = request.message[:20] + "..." if len(request.message) > 20 else request.message
        chat_in = schemas.ChatCreate(title=title)
        chat = crud.chat.create_with_user(db=db, obj_in=chat_in, user_id=current_user.id)
        chat_id = chat.id
    
    # 保存用户消息
    user_message = schemas.ChatMessageCreate(
        chat_id=chat_id,
        role="user",
        content=request.message
    )
    crud.chat_message.create(db=db, obj_in=user_message)
    
    # 获取聊天历史
    chat_history = crud.chat_message.get_chat_history(db=db, chat_id=chat_id)
    
    # 搜索相关知识
    knowledge_results = search_knowledge(
        db=db, 
        query=request.message, 
        organization_id=current_user.organization_id
    )
    
    # 构建知识上下文
    knowledge_context = ""
    knowledge_sources = []
    if knowledge_results:
        for result in knowledge_results:
            knowledge_context += f"\n---\n{result['content']}\n"
            knowledge_sources.append({
                "id": result["id"],
                "title": result["title"],
                "relevance": result["relevance"]
            })
    
    # 如果是流式响应
    if request.stream:
        return StreamingResponse(
            get_llm_response(
                user_message=request.message, 
                chat_history=chat_history,
                knowledge_context=knowledge_context,
                stream=True
            ),
            media_type="text/event-stream"
        )
    
    # 非流式响应
    ai_response, tokens = await get_llm_response(
        user_message=request.message, 
        chat_history=chat_history,
        knowledge_context=knowledge_context
    )
    
    # 保存AI回复
    assistant_message = schemas.ChatMessageCreate(
        chat_id=chat_id,
        role="assistant",
        content=ai_response,
        knowledge_sources=json.dumps(knowledge_sources) if knowledge_sources else None,
        tokens=tokens
    )
    db_message = crud.chat_message.create(db=db, obj_in=assistant_message)
    
    # 更新聊天会话时间
    background_tasks.add_task(crud.chat.update_timestamp, db=db, id=chat_id)
    
    return {
        "id": str(uuid.uuid4()),
        "message": db_message,
        "chat_id": chat_id,
        "created_at": datetime.now(),
        "knowledge_sources": knowledge_sources
    }
```

### 2. 知识搜索服务

```python:backend/app/services/knowledge_search.py
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from sqlalchemy import func, desc, or_

from app.models.knowledge import Knowledge
from app.models.organization import Organization

def search_knowledge(
    db: Session, 
    query: str, 
    organization_id: int,
    limit: int = 5
) -> List[Dict[str, Any]]:
    """
    搜索知识库，返回与查询相关的结果。
    """
    # 简单实现：基于关键词匹配
    search_term = f"%{query}%"
    
    # 查询相关知识条目
    results = db.query(
        Knowledge.id,
        Knowledge.title,
        Knowledge.content,
        Knowledge.summary
    ).filter(
        Knowledge.organization_id == organization_id,
        Knowledge.status == "published",
        or_(
            Knowledge.title.ilike(search_term),
            Knowledge.content.ilike(search_term),
            Knowledge.summary.ilike(search_term)
        )
    ).order_by(
        desc(
            # 简单相关性评分：标题匹配权重高于内容
            (func.position(func.lower(query), func.lower(Knowledge.title)) > 0) * 3 +
            (func.position(func.lower(query), func.lower(Knowledge.content)) > 0) * 1
        )
    ).limit(limit).all()
    
    # 格式化结果
    formatted_results = []
    for result in results:
        # 提取匹配的片段作为上下文
        content = result.content
        summary = result.summary
        
        # 优先使用摘要，如果没有则从内容中提取
        context = summary if summary else (
            content[:500] + "..." if len(content) > 500 else content
        )
        
        formatted_results.append({
            "id": result.id,
            "title": result.title,
            "content": context,
            "relevance": 0.8  # 简单实现，固定相关性分数
        })
    
    return formatted_results
```

### 3. 大语言模型服务

```python:backend/app/services/llm_service.py
from typing import List, Dict, Any, Optional, Tuple, AsyncGenerator
import httpx
import json
import asyncio
from app.core.config import settings

async def get_llm_response(
    user_message: str,
    chat_history: List[Dict[str, Any]],
    knowledge_context: Optional[str] = None,
    stream: bool = False
) -> Tuple[str, int] | AsyncGenerator[str, None]:
    """
    获取大语言模型的回复。
    """
    # 构建系统提示
    system_prompt = "你是一个企业智能知识库助手，请根据提供的知识信息回答问题。如果没有足够信息，请诚实地说明你不知道，不要编造答案。"
    
    if knowledge_context:
        system_prompt += "\n\n以下是与用户问题相关的知识库内容，请参考这些内容回答问题：\n" + knowledge_context
    
    # 构建消息历史
    messages = [{"role": "system", "content": system_prompt}]
    
    # 添加历史消息（最多5轮对话）
    recent_history = chat_history[-10:] if len(chat_history) > 10 else chat_history
    for msg in recent_history:
        messages.append({"role": msg["role"], "content": msg["content"]})
    
    # 添加当前用户消息
    messages.append({"role": "user", "content": user_message})
    
    # 准备API请求
    api_key = settings.OPENAI_API_KEY
    endpoint = settings.OPENAI_API_ENDPOINT
    model = settings.OPENAI_MODEL_NAME
    
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": model,
        "messages": messages,
        "temperature": 0.7,
        "stream": stream
    }
    
    # 流式响应
    if stream:
        async def stream_response():
            async with httpx.AsyncClient(timeout=60.0) as client:
                async with client.stream(
                    "POST", 
                    endpoint, 
                    headers=headers, 
                    json=payload
                ) as response:
                    if response.status_code != 200:
                        error_detail = await response.text()
                        raise Exception(f"API请求失败: {error_detail}")
                    
                    # 处理流式响应
                    buffer = ""
                    async for chunk in response.aiter_text():
                        if chunk.startswith("data: "):
                            chunk = chunk[6:]
                        if chunk.strip() == "[DONE]":
                            continue
                        try:
                            data = json.loads(chunk)
                            content = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
                            if content:
                                buffer += content
                                yield content
                        except json.JSONDecodeError:
                            pass
        
        return stream_response()
    
    # 非流式响应
    async with httpx.AsyncClient(timeout=60.0) as client:
        response = await client.post(endpoint, headers=headers, json=payload)
        
        if response.status_code != 200:
            raise Exception(f"API请求失败: {response.text}")
        
        result = response.json()
        message = result["choices"][0]["message"]["content"]
        tokens = result["usage"]["total_tokens"]
        
        return message, tokens
```

### 4. 智能问答前端页面

```typescript:frontend/src/pages/chat/index.tsx
import { useState, useEffect, useRef } from 'react';
import { 
  Layout, 
  Input, 
  Button, 
  List, 
  Avatar, 
  Spin, 
  Divider, 
  Tooltip,
  Empty,
  Space,
  Menu
} from 'antd';
import { 
  SendOutlined, 
  UserOutlined, 
  RobotOutlined,
  PlusOutlined,
  MessageOutlined,
  DeleteOutlined
} from '@ant-design/icons';
import { useRouter } from 'next/router';
import MainLayout from '@/components/layouts/MainLayout';
import { getToken } from '@/utils/auth';
import ReactMarkdown from 'react-markdown';

const { Sider, Content } = Layout;

interface ChatMessage {
  id: number;
  role: string;
  content: string;
  knowledge_sources?: string;
  created_at: string;
}

interface Chat {
  id: number;
  title: string;
  messages: ChatMessage[];
  created_at: string;
  updated_at: string;
}

interface KnowledgeSource {
  id: number;
  title: string;
  relevance: number;
}

const ChatPage = () => {
  const [chats, setChats] = useState<Chat[]>([]);
  const [currentChat, setCurrentChat] = useState<Chat | null>(null);
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [sending, setSending] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const router = useRouter();
  const { chatId } = router.query;

  useEffect(() => {
    fetchChats();
  }, []);

  useEffect(() => {
    if (chatId && chats.length > 0) {
      const chat = chats.find(c => c.id === parseInt(chatId as string));
      if (chat) {
        setCurrentChat(chat);
      }
    }
  }, [chatId, chats]);

  useEffect(() => {
    scrollToBottom();
  }, [currentChat]);

  const fetchChats = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/chat', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setChats(data);
        
        if (data.length > 0 && !currentChat) {
          if (chatId) {
            const chat = data.find((c: Chat) => c.id === parseInt(chatId as string));
            if (chat) {
              setCurrentChat(chat);
            } else {
              setCurrentChat(data[0]);
            }
          } else {
            setCurrentChat(data[0]);
          }
        }
      } else {
        throw new Error('获取聊天列表失败');
      }
    } catch (error) {
      console.error('获取聊天列表失败', error);
    } finally {
      setLoading(false);
    }
  };

  const createNewChat = async () => {
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify({
          title: '新对话'
        })
      });
      
      if (response.ok) {
        const newChat = await response.json();
        setChats([newChat, ...chats]);
        setCurrentChat(newChat);
        router.push(`/chat?chatId=${newChat.id}`, undefined, { shallow: true });
      } else {
        throw new Error('创建新对话失败');
      }
    } catch (error) {
      console.error('创建新对话失败', error

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统设计与开发

## 四、智能问答系统实现(续)

### 4. 智能问答前端页面(续)

```typescript:frontend/src/pages/chat/index.tsx
    } catch (error) {
      console.error('创建新对话失败', error);
    }
  };

  const deleteChat = async (chatId: number, e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      const response = await fetch(`/api/chat/${chatId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        setChats(chats.filter(chat => chat.id !== chatId));
        if (currentChat && currentChat.id === chatId) {
          setCurrentChat(chats.length > 1 ? chats.find(chat => chat.id !== chatId)! : null);
        }
      } else {
        throw new Error('删除对话失败');
      }
    } catch (error) {
      console.error('删除对话失败', error);
    }
  };

  const sendMessage = async () => {
    if (!message.trim() || sending) return;
    
    setSending(true);
    
    try {
      // 先在UI上添加用户消息
      const tempUserMessage = {
        id: Date.now(),
        role: 'user',
        content: message,
        created_at: new Date().toISOString()
      };
      
      let chatId = currentChat?.id;
      let updatedMessages = currentChat?.messages 
        ? [...currentChat.messages, tempUserMessage] 
        : [tempUserMessage];
      
      if (currentChat) {
        setCurrentChat({
          ...currentChat,
          messages: updatedMessages
        });
      }
      
      // 清空输入框
      setMessage('');
      
      // 滚动到底部
      setTimeout(scrollToBottom, 100);
      
      // 发送请求获取AI回复
      const response = await fetch('/api/chat/completion', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getToken()}`
        },
        body: JSON.stringify({
          chat_id: chatId,
          message: tempUserMessage.content,
          stream: false
        })
      });
      
      if (!response.ok) {
        throw new Error('发送消息失败');
      }
      
      const data = await response.json();
      
      // 如果是新会话，重新获取会话列表
      if (!chatId) {
        fetchChats();
        router.push(`/chat?chatId=${data.chat_id}`, undefined, { shallow: true });
      } else {
        // 添加AI回复
        const aiMessage = data.message;
        
        updatedMessages = [...updatedMessages, aiMessage];
        
        if (currentChat) {
          setCurrentChat({
            ...currentChat,
            messages: updatedMessages
          });
        }
        
        // 更新聊天列表中的会话
        setChats(chats.map(chat => 
          chat.id === chatId ? { ...chat, messages: updatedMessages } : chat
        ));
        
        // 滚动到底部
        setTimeout(scrollToBottom, 100);
      }
    } catch (error) {
      console.error('发送消息失败', error);
    } finally {
      setSending(false);
    }
  };

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const parseKnowledgeSources = (sourcesJson: string | undefined): KnowledgeSource[] => {
    if (!sourcesJson) return [];
    try {
      return JSON.parse(sourcesJson);
    } catch (error) {
      console.error('解析知识来源失败', error);
      return [];
    }
  };

  const renderChatList = () => {
    if (chats.length === 0) {
      return (
        <div className="p-6 text-center">
          <Empty description="暂无聊天记录" />
        </div>
      );
    }
    
    return (
      <Menu
        className="border-0"
        selectedKeys={currentChat ? [`chat-${currentChat.id}`] : []}
      >
        {chats.map(chat => (
          <Menu.Item 
            key={`chat-${chat.id}`}
            onClick={() => {
              setCurrentChat(chat);
              router.push(`/chat?chatId=${chat.id}`, undefined, { shallow: true });
            }}
            className="flex justify-between items-center group"
            icon={<MessageOutlined />}
          >
            <div className="flex justify-between items-center w-full">
              <div className="truncate flex-1">{chat.title}</div>
              <Button
                type="text"
                icon={<DeleteOutlined />}
                size="small"
                className="opacity-0 group-hover:opacity-100 transition-opacity"
                onClick={(e) => deleteChat(chat.id, e)}
              />
            </div>
          </Menu.Item>
        ))}
      </Menu>
    );
  };

  return (
    <MainLayout>
      <Layout className="bg-white h-full">
        <Sider width={250} theme="light" className="border-r">
          <div className="p-4">
            <Button 
              type="primary" 
              icon={<PlusOutlined />} 
              onClick={createNewChat}
              block
            >
              新的对话
            </Button>
          </div>
          <div className="overflow-y-auto" style={{ height: 'calc(100vh - 120px)' }}>
            {renderChatList()}
          </div>
        </Sider>
        <Content className="p-0 flex flex-col">
          <div 
            className="flex-1 overflow-y-auto p-6" 
            style={{ height: 'calc(100vh - 180px)' }}
          >
            {!currentChat ? (
              <div className="flex items-center justify-center h-full">
                <div className="text-center">
                  <h2 className="text-xl font-bold mb-4">企业智能知识库助手</h2>
                  <p className="text-gray-500 mb-8">基于企业知识库提供智能问答服务</p>
                  <Button 
                    type="primary"
                    icon={<MessageOutlined />}
                    size="large"
                    onClick={createNewChat}
                  >
                    开始对话
                  </Button>
                </div>
              </div>
            ) : (
              <>
                {currentChat.messages.length === 0 ? (
                  <div className="flex items-center justify-center h-full">
                    <div className="text-center">
                      <h2 className="text-xl font-bold mb-4">开始一个新对话</h2>
                      <p className="text-gray-500">您可以问任何关于企业知识库的问题</p>
                    </div>
                  </div>
                ) : (
                  <List
                    itemLayout="horizontal"
                    dataSource={currentChat.messages}
                    renderItem={item => {
                      const isUser = item.role === 'user';
                      const knowledgeSources = parseKnowledgeSources(item.knowledge_sources);
                      
                      return (
                        <List.Item className={`${isUser ? 'justify-end' : 'justify-start'}`}>
                          <div 
                            className={`
                              max-w-3xl rounded-lg p-4 
                              ${isUser ? 'bg-blue-50' : 'bg-gray-50'}
                            `}
                          >
                            <div className="flex items-start mb-2">
                              <Avatar 
                                icon={isUser ? <UserOutlined /> : <RobotOutlined />} 
                                className={isUser ? 'bg-blue-500' : 'bg-green-500'}
                              />
                              <span className="ml-2 font-bold">
                                {isUser ? '我' : '智能助手'}
                              </span>
                            </div>
                            
                            <div className="ml-8">
                              {isUser ? (
                                <p className="whitespace-pre-wrap">{item.content}</p>
                              ) : (
                                <ReactMarkdown className="prose">
                                  {item.content}
                                </ReactMarkdown>
                              )}
                              
                              {knowledgeSources.length > 0 && (
                                <div className="mt-4 pt-2 border-t border-gray-200">
                                  <p className="text-sm text-gray-500 mb-1">参考来源:</p>
                                  <div className="flex flex-wrap gap-2">
                                    {knowledgeSources.map((source, index) => (
                                      <Tooltip 
                                        key={index} 
                                        title={`相关度: ${Math.round(source.relevance * 100)}%`}
                                      >
                                        <Button 
                                          size="small"
                                          onClick={() => router.push(`/knowledge/${source.id}`)}
                                        >
                                          {source.title}
                                        </Button>
                                      </Tooltip>
                                    ))}
                                  </div>
                                </div>
                              )}
                            </div>
                          </div>
                        </List.Item>
                      );
                    }}
                  />
                )}
                <div ref={messagesEndRef} />
              </>
            )}
          </div>
          
          <div className="p-4 border-t">
            <div className="flex items-center">
              <Input
                placeholder="输入您的问题..."
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                onPressEnter={sendMessage}
                disabled={sending}
                size="large"
              />
              <Button
                type="primary"
                icon={sending ? <Spin size="small" /> : <SendOutlined />}
                onClick={sendMessage}
                disabled={sending || !message.trim()}
                className="ml-2"
                size="large"
              >
                发送
              </Button>
            </div>
          </div>
        </Content>
      </Layout>
    </MainLayout>
  );
};

export default ChatPage;
```

### 5. 富文本编辑器组件

```typescript:frontend/src/components/features/Editor.tsx
import React, { useState, useEffect } from 'react';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';

interface EditorProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

const modules = {
  toolbar: [
    [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
    ['bold', 'italic', 'underline', 'strike'],
    [{ 'list': 'ordered' }, { 'list': 'bullet' }],
    [{ 'indent': '-1' }, { 'indent': '+1' }],
    [{ 'color': [] }, { 'background': [] }],
    ['link', 'image', 'video'],
    ['clean']
  ],
};

const formats = [
  'header',
  'bold', 'italic', 'underline', 'strike',
  'list', 'bullet', 'indent',
  'link', 'image', 'video',
  'color', 'background'
];

const Editor: React.FC<EditorProps> = ({ value, onChange, placeholder }) => {
  // 解决ReactQuill水合性错误的处理
  const [mounted, setMounted] = useState(false);
  
  useEffect(() => {
    setMounted(true);
  }, []);
  
  if (!mounted) {
    return <div className="h-96 border rounded-md"></div>;
  }
  
  return (
    <ReactQuill
      theme="snow"
      value={value}
      onChange={onChange}
      modules={modules}
      formats={formats}
      placeholder={placeholder}
      className="h-96"
    />
  );
};

export default Editor;
```

### 6. 主布局组件

```typescript:frontend/src/components/layouts/MainLayout.tsx
import React, { useState, useEffect } from 'react';
import { Layout, Menu, Button, Avatar, Dropdown, Input } from 'antd';
import { 
  UserOutlined,
  SearchOutlined,
  AppstoreOutlined,
  FileOutlined,
  MessageOutlined,
  SettingOutlined,
  LogoutOutlined,
  MenuUnfoldOutlined,
  MenuFoldOutlined
} from '@ant-design/icons';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { clearToken } from '@/utils/auth';

const { Header, Sider, Content } = Layout;

interface MainLayoutProps {
  children: React.ReactNode;
}

const MainLayout: React.FC<MainLayoutProps> = ({ children }) => {
  const [collapsed, setCollapsed] = useState(false);
  const [username, setUsername] = useState('');
  const [isAdmin, setIsAdmin] = useState(false);
  const router = useRouter();

  useEffect(() => {
    // 获取当前用户信息
    const fetchUserInfo = async () => {
      try {
        const response = await fetch('/api/users/me');
        if (response.ok) {
          const user = await response.json();
          setUsername(user.username);
          setIsAdmin(user.is_admin);
        }
      } catch (error) {
        console.error('获取用户信息失败', error);
      }
    };

    fetchUserInfo();
  }, []);

  const handleLogout = () => {
    clearToken();
    router.push('/login');
  };

  // 确定当前活动菜单项
  const getSelectedKeys = () => {
    const path = router.pathname;
    if (path === '/') return ['home'];
    if (path.startsWith('/knowledge')) return ['knowledge'];
    if (path.startsWith('/chat')) return ['chat'];
    if (path.startsWith('/search')) return ['search'];
    return [];
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider 
        trigger={null} 
        collapsible 
        collapsed={collapsed}
        width={220}
        theme="dark"
      >
        <div className="p-4 h-16 flex items-center">
          <div className="text-white text-lg font-bold truncate">
            {!collapsed && '企业智能知识库'}
            {collapsed && 'WK'}
          </div>
        </div>
        <Menu
          theme="dark"
          mode="inline"
          selectedKeys={getSelectedKeys()}
          items={[
            {
              key: 'home',
              icon: <AppstoreOutlined />,
              label: <Link href="/">首页</Link>,
            },
            {
              key: 'knowledge',
              icon: <FileOutlined />,
              label: <Link href="/knowledge">知识库</Link>,
            },
            {
              key: 'chat',
              icon: <MessageOutlined />,
              label: <Link href="/chat">智能问答</Link>,
            },
            {
              key: 'search',
              icon: <SearchOutlined />,
              label: <Link href="/search">搜索</Link>,
            },
            isAdmin && {
              key: 'admin',
              icon: <SettingOutlined />,
              label: <Link href="/admin/dashboard">管理后台</Link>,
            },
          ].filter(Boolean)}
        />
      </Sider>
      <Layout>
        <Header className="bg-white p-0 px-4 flex justify-between items-center shadow-sm">
          <Button
            type="text"
            icon={collapsed ? <MenuUnfoldOutlined /> : <MenuFoldOutlined />}
            onClick={() => setCollapsed(!collapsed)}
            className="text-lg"
          />
          <div className="flex items-center">
            <div className="mr-4">
              <Input
                placeholder="搜索知识..."
                prefix={<SearchOutlined />}
                style={{ width: 220 }}
                onPressEnter={(e) => router.push(`/search?q=${encodeURIComponent(e.currentTarget.value)}`)}
              />
            </div>
            <Dropdown menu={{
              items: [
                { key: 'profile', label: '个人信息', icon: <UserOutlined /> },
                { key: 'logout', label: '退出登录', icon: <LogoutOutlined />, onClick: handleLogout }
              ]
            }}>
              <div className="flex items-center cursor-pointer">
                <Avatar icon={<UserOutlined />} className="mr-2" />
                <span>{username}</span>
              </div>
            </Dropdown>
          </div>
        </Header>
        <Content className="m-4 overflow-auto">
          {children}
        </Content>
      </Layout>
    </Layout>
  );
};

export default MainLayout;
```

## 五、搜索页面实现

```typescript:frontend/src/pages/search/index.tsx
import { useState, useEffect } from 'react';
import { 
  Input, 
  Button, 
  List, 
  Tag, 
  Empty, 
  Spin, 
  Card, 
  Select, 
  Divider,
  Typography,
  Space
} from 'antd';
import { 
  SearchOutlined, 
  FileOutlined,
  TagOutlined,
  FolderOutlined
} from '@ant-design/icons';
import { useRouter } from 'next/router';
import MainLayout from '@/components/layouts/MainLayout';
import { getToken } from '@/utils/auth';
import Link from 'next/link';

const { Option } = Select;
const { Title, Paragraph, Text } = Typography;

interface KnowledgeItem {
  id: number;
  title: string;
  summary: string;
  category_id: number;
  category: { id: number; name: string };
  tags: { id: number; name: string; color: string }[];
  status: string;
  view_count: number;
  updated_at: string;
}

interface Category {
  id: number;
  name: string;
  children?: Category[];
}

interface Tag {
  id: number;
  name: string;
  color: string;
}

const SearchPage = () => {
  const [searchValue, setSearchValue] = useState('');
  const [results, setResults] = useState<KnowledgeItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [categories, setCategories] = useState<Category[]>([]);
  const [tags, setTags] = useState<Tag[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<number | null>(null);
  const [selectedTag, setSelectedTag] = useState<number | null>(null);
  const [searchPerformed, setSearchPerformed] = useState(false);
  const router = useRouter();
  const { q } = router.query;

  useEffect(() => {
    fetchCategories();
    fetchTags();
  }, []);

  useEffect(() => {
    if (q) {
      setSearchValue(q as string);
      performSearch(q as string);
    }
  }, [q]);

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setCategories(data);
      }
    } catch (error) {
      console.error('获取分类失败', error);
    }
  };

  const fetchTags = async () => {
    try {
      const response = await fetch('/api/tags', {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setTags(data);
      }
    } catch (error) {
      console.error('获取标签失败', error);
    }
  };

  const performSearch = async (queryText: string) => {
    if (!queryText.trim()) return;
    
    setLoading(true);
    setSearchPerformed(true);
    
    try {
      const params = new URLSearchParams();
      params.append('q', queryText);
      
      if (selectedCategory) {
        params.append('category_id', selectedCategory.toString());
      }
      
      if (selectedTag) {
        params.append('tag_id', selectedTag.toString());
      }
      
      const response = await fetch(`/api/search?${params.toString()}`, {
        headers: {
          'Authorization': `Bearer ${getToken()}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        setResults(data);
      } else {
        throw new Error('搜索失败');
      }
    } catch (error) {
      console.error('搜索失败', error);
      setResults([]);
    } finally {
      setLoading(false);
    }
  };

  const handleSearch = () => {
    router.push({
      pathname: '/search',
      query: { q: searchValue, ...(selectedCategory && { category: selectedCategory }) }
    }, undefined, { shallow: true });
    
    performSearch(searchValue);
  };

  const handleCategoryChange = (value: number | null) => {
    setSelectedCategory(value);
    if (searchPerformed && searchValue) {
      performSearch(searchValue);
    }
  };

  const handleTagChange = (value: number | null) => {
    setSelectedTag(value);
    if (searchPerformed && searchValue) {
      performSearch(searchValue);
    }
  };

  const highlightSearchTerm = (text: string, term: string) => {
    if (!term || !text) return text;
    
    const parts = text.split(new RegExp(`(${term})`, 'gi'));
    return (
      <>
        {parts.map((part, index) => 
          part.toLowerCase() === term.toLowerCase() 
            ? <mark key={index} className="bg-yellow-200">{part}</mark> 
            : part
        )}
      </>
    );
  };

  return (
    <MainLayout>
      <div className="p-6 bg-white rounded-lg">
        <div className="mb-6">
          <Title level={2}>知识搜索</Title>
          <Paragraph className="text-gray-500">
            搜索企业知识库中的内容，找到您需要的信息
          </Paragraph>
        </div>
        
        <div className="flex mb-6">
          <Input
            placeholder="输入搜索关键词..."
            value={searchValue}
            onChange={(e) => setSearchValue(e.target.value)}
            onPressEnter={handleSearch}
            className="mr-2"
            size="large"
          />
          <Button
            type="primary"
            icon={<SearchOutlined />}
            onClick={handleSearch}
            size="large"
          >
            搜索
          </Button>
        </div>
        
        <div className="flex mb-6">
          <Space wrap>
            <span className="text-gray-500 mr-2">分类:</span>
            <Select
              placeholder="所有分类"
              style={{ width: 200 }}
              allowClear
              onChange={handleCategoryChange}
              value={selectedCategory}
            >
              {categories.map(category => (
                <Option key={category.id} value={category.id}>{category.name}</Option>
              ))}
            </Select>
            
            <span className="text-gray-500 mr-2 ml-4">标签:</span>
            <Select
              placeholder="所有标签"
              style={{ width: 200 }}
              allowClear
              onChange={handleTagChange}
              value={selectedTag}
            >
              {tags.map(tag => (
                <Option key={tag.id} value={tag.id}>
                  <div className="flex items-center">
                    <div 
                      className="w-3 h-3 rounded-full mr-2"
                      style={{ backgroundColor: tag.color || '#1890ff' }}
                    />
                    {tag.name}
                  </div>
                </Option>
              ))}
            </Select>
          </Space>
        </div>
        
        <Divider />
        
        {loading ? (
          <div className="text-center py-12">
            <Spin size="large" />
            <div className="mt-4 text-gray-500">搜索中...</div>
          </div>
        ) : searchPerformed ? (
          results.length > 0 ? (
            <div>
              <div className="mb-4">
                找到 <strong>{results.length}</strong> 条相关结果
              </div>
              <List
                itemLayout="vertical"
                dataSource={results}
                renderItem={item => (
                  <List.Item
                    key={item.id}
                    actions={[
                      <Space key="category">
                        <FolderOutlined />
                        {item.category ? item.category.name : '未分类'}
                      </Space>,
                      <Space key="updated">
                        更新于 {new Date(item.updated_at).toLocaleDateString()}
                      </Space>,
                      <Space key="views">
                        {item.view_count} 次浏览
                      </Space>
                    ]}
                    extra={
                      <div className="flex flex-wrap gap-1">
                        {item.tags.map(tag => (
                          <Tag 
                            key={tag.id} 
                            color={tag.color || 'blue'}
                            icon={<TagOutlined />}
                          >
                            {tag.name}
                          </Tag>
                        ))}
                      </div>
                    }
                  >
                    <List.Item.Meta
                      title={
                        <Link href={`/knowledge/${item.id}`}>
                          {highlightSearchTerm(item.title, searchValue)}
                        </Link>
                      }
                    />
                    <div>
                      {highlightSearchTerm(item.summary || '无摘要', searchValue)}
                    </div>
                  </List.Item>
                )}
              />
            </div>
          ) : (
            <Empty
              description={
                <span>
                  未找到与 <strong>"{searchValue}"</strong> 相关的内容
                </span>
              }
            />
          )
        ) : (
          <div className="text-center py-12 text-gray-500">
            <FileOutlined style={{ fontSize: 48 }} />
            <p className="mt-4">请输入关键词进行搜索</p>
          </div>
        )}
      </div>
    </MainLayout>
  );
};

export default SearchPage;
```

## 六、系统总结

经过以上设计与开发，我们已经完成了企业智能知识库平台的核心功能构建，包括：

### 1. 用户体系与权限管理

- 基于JWT的用户认证
- 角色权限控制（管理员/普通用户）
- 组织架构管理
- 用户管理

### 2. 知识库管理系统

- 知识分类与标签管理
- 知识条目的创建、编辑、删除
- 知识内容富文本编辑
- 附件管理

### 3. 智能问答系统

- 基于大语言模型的问答功能
- 知识库搜索与检索
- 聊天会话管理
- 知识来源引用

### 4. 搜索功能

- 全文搜索
- 分类与标签过滤
- 搜索结果高亮显示

### 5. 系统设置与配置

- 系统基础设置
- 邮件系统设置
- 模型配置
- 数据源管理

## 七、后续优化方向

1. **知识库检索优化**：
   - 集成向量数据库（如Pinecone、Milvus）实现语义搜索
   - 实现OCR提取PDF、图片中的文本内容
   - 添加文档自动分类功能

2. **大语言模型优化**：
   - 实现模型微调功能，基于企业特定数据定制模型
   - 添加多模型切换功能
   - 提升对话上下文处理能力

3. **知识管理功能扩展**：
   - 版本控制与历史记录
   - 知识审核与发布流程
   - 协作编辑功能
   - 知识地图可视化

4. **用户体验优化**：
   - 移动端适配
   - 主题定制
   - 数据可视化报表
   - 用户行为分析

5. **系统安全与性能**：
   - 实现细粒度权限控制
   - 数据备份与恢复
   - 缓存系统优化
   - 负载均衡与高可用性部署

通过以上开发，我们已经构建了一个功能完整的企业智能知识库平台，能够满足企业内部知识管理、查询和智能问答的基本需求。后续可以根据实际使用情况和用户反馈，持续迭代优化，提升系统的功能性、易用性和性能。

---

_**User**_

先完成后续的1、2、3

---

_**Assistant**_



---

# 继续完成系统优化功能

## 一、知识库检索优化

### 1. 向量数据库集成

首先添加向量数据库依赖和配置：

```python:backend/requirements.txt
# ... existing dependencies ...
pinecone-client==2.2.1
sentence-transformers==2.2.2
openai==1.3.0
```

```python:backend/app/core/config.py
# ... existing code ...

class Settings(BaseSettings):
    # ... existing settings ...
    
    # 向量数据库设置
    VECTOR_DB_TYPE: str = "pinecone"  # pinecone, milvus, qdrant
    PINECONE_API_KEY: str = ""
    PINECONE_ENVIRONMENT: str = ""
    PINECONE_INDEX_NAME: str = "knowledge-index"
    VECTOR_DIMENSION: int = 768  # 使用sentence-transformers时
    
    # 嵌入模型设置
    EMBEDDING_MODEL: str = "all-MiniLM-L6-v2"  # 默认使用sentence-transformers模型
    EMBEDDING_MODEL_TYPE: str = "sentence_transformers"  # sentence_transformers, openai
    
    # ... existing code ...
```

创建向量数据库服务：

```python:backend/app/services/vector_db.py
from typing import List, Dict, Any, Optional, Union
import json
import numpy as np
from app.core.config import settings
import logging

logger = logging.getLogger(__name__)

# 导入相应的向量数据库客户端
if settings.VECTOR_DB_TYPE == "pinecone":
    import pinecone
    from pinecone import PodSpec
elif settings.VECTOR_DB_TYPE == "milvus":
    from pymilvus import Collection, connections, utility
elif settings.VECTOR_DB_TYPE == "qdrant":
    from qdrant_client import QdrantClient
    from qdrant_client.models import Distance, VectorParams

# 导入嵌入模型
if settings.EMBEDDING_MODEL_TYPE == "sentence_transformers":
    from sentence_transformers import SentenceTransformer
    embedding_model = SentenceTransformer(settings.EMBEDDING_MODEL)
elif settings.EMBEDDING_MODEL_TYPE == "openai":
    import openai
    openai.api_key = settings.OPENAI_API_KEY

class VectorDBService:
    """向量数据库服务，支持不同的向量数据库和嵌入模型"""
    
    def __init__(self):
        self.db_type = settings.VECTOR_DB_TYPE
        self.initialized = False
        self.init_vector_db()
    
    def init_vector_db(self):
        """初始化向量数据库连接"""
        if self.db_type == "pinecone":
            try:
                pinecone.init(
                    api_key=settings.PINECONE_API_KEY,
                    environment=settings.PINECONE_ENVIRONMENT
                )
                
                # 检查索引是否存在，不存在则创建
                if settings.PINECONE_INDEX_NAME not in pinecone.list_indexes():
                    pinecone.create_index(
                        name=settings.PINECONE_INDEX_NAME,
                        dimension=settings.VECTOR_DIMENSION,
                        metric="cosine",
                        spec=PodSpec(environment=settings.PINECONE_ENVIRONMENT)
                    )
                
                self.index = pinecone.Index(settings.PINECONE_INDEX_NAME)
                self.initialized = True
                logger.info(f"Pinecone initialized with index: {settings.PINECONE_INDEX_NAME}")
            except Exception as e:
                logger.error(f"Failed to initialize Pinecone: {e}")
                
        elif self.db_type == "milvus":
            # Milvus实现代码...
            pass
        
        elif self.db_type == "qdrant":
            # Qdrant实现代码...
            pass
    
    def generate_embedding(self, text: str) -> List[float]:
        """生成文本的嵌入向量"""
        if settings.EMBEDDING_MODEL_TYPE == "sentence_transformers":
            embedding = embedding_model.encode(text)
            return embedding.tolist()
        elif settings.EMBEDDING_MODEL_TYPE == "openai":
            response = openai.Embedding.create(
                input=text,
                model="text-embedding-ada-002"
            )
            return response['data'][0]['embedding']
    
    def upsert_document(self, doc_id: str, content: str, metadata: Dict[str, Any]):
        """添加或更新文档向量"""
        if not self.initialized:
            logger.error("Vector DB not initialized")
            return False
        
        try:
            # 生成嵌入向量
            vector = self.generate_embedding(content)
            
            if self.db_type == "pinecone":
                self.index.upsert(
                    vectors=[(doc_id, vector, metadata)],
                    namespace="knowledge"
                )
            # 其他数据库的实现...
            
            return True
        except Exception as e:
            logger.error(f"Error upserting document: {e}")
            return False
    
    def delete_document(self, doc_id: str):
        """删除文档向量"""
        if not self.initialized:
            logger.error("Vector DB not initialized")
            return False
        
        try:
            if self.db_type == "pinecone":
                self.index.delete(ids=[doc_id], namespace="knowledge")
            # 其他数据库的实现...
            
            return True
        except Exception as e:
            logger.error(f"Error deleting document: {e}")
            return False
    
    def search(self, query: str, top_k: int = 5, filter: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """搜索相似文档"""
        if not self.initialized:
            logger.error("Vector DB not initialized")
            return []
        
        try:
            # 生成查询向量
            query_vector = self.generate_embedding(query)
            
            if self.db_type == "pinecone":
                results = self.index.query(
                    vector=query_vector,
                    top_k=top_k,
                    namespace="knowledge",
                    filter=filter,
                    include_metadata=True
                )
                
                return [
                    {
                        "id": match.id,
                        "score": match.score,
                        "metadata": match.metadata
                    }
                    for match in results.matches
                ]
            # 其他数据库的实现...
            
            return []
        except Exception as e:
            logger.error(f"Error searching documents: {e}")
            return []

# 创建服务实例
vector_db_service = VectorDBService()
```

### 2. 知识内容的向量化与检索

添加知识内容向量化相关代码：

```python:backend/app/services/knowledge_vectorize.py
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
import uuid
import json

from app.models.knowledge import Knowledge
from app.services.vector_db import vector_db_service
from app.core.config import settings

def vectorize_knowledge(knowledge_id: int, db: Session):
    """将知识条目向量化并存储到向量数据库"""
    # 获取知识条目
    knowledge = db.query(Knowledge).filter(Knowledge.id == knowledge_id).first()
    if not knowledge:
        return False
    
    # 准备文本内容
    content = knowledge.title + "\n" + (knowledge.content or "")
    
    # 准备元数据
    metadata = {
        "knowledge_id": knowledge.id,
        "title": knowledge.title,
        "organization_id": knowledge.organization_id,
        "category_id": knowledge.category_id,
        "status": knowledge.status,
        "is_public": knowledge.is_public,
        "created_at": str(knowledge.created_at),
        "updated_at": str(knowledge.updated_at) if knowledge.updated_at else None
    }
    
    # 生成文档ID
    doc_id = f"knowledge_{knowledge.id}"
    
    # 上传到向量数据库
    success = vector_db_service.upsert_document(doc_id, content, metadata)
    
    return success

def delete_knowledge_vector(knowledge_id: int):
    """从向量数据库中删除知识条目向量"""
    doc_id = f"knowledge_{knowledge_id}"
    return vector_db_service.delete_document(doc_id)

def bulk_vectorize_knowledge(db: Session, batch_size: int = 50):
    """批量向量化所有已发布的知识条目"""
    # 分批获取所有已发布的知识条目
    offset = 0
    total_processed = 0
    
    while True:
        knowledge_items = db.query(Knowledge).filter(
            Knowledge.status == "published"
        ).offset(offset).limit(batch_size).all()
        
        if not knowledge_items:
            break
        
        for item in knowledge_items:
            success = vectorize_knowledge(item.id, db)
            if success:
                total_processed += 1
        
        offset += batch_size
    
    return total_processed
```

更新知识搜索服务，支持向量搜索：

```python:backend/app/services/knowledge_search.py
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from sqlalchemy import func, desc, or_

from app.models.knowledge import Knowledge
from app.models.organization import Organization
from app.services.vector_db import vector_db_service

def search_knowledge(
    db: Session, 
    query: str, 
    organization_id: int,
    limit: int = 5,
    use_vector_search: bool = True  # 添加向量搜索选项
) -> List[Dict[str, Any]]:
    """
    搜索知识库，返回与查询相关的结果。
    支持传统关键词搜索和向量语义搜索。
    """
    # 如果启用向量搜索
    if use_vector_search:
        # 设置过滤条件
        filter_dict = {
            "organization_id": organization_id,
            "status": "published"
        }
        
        # 搜索向量数据库
        vector_results = vector_db_service.search(
            query=query,
            top_k=limit,
            filter=filter_dict
        )
        
        # 如果有结果，获取完整的知识条目
        if vector_results:
            knowledge_ids = [int(result["metadata"]["knowledge_id"]) for result in vector_results]
            
            # 获取知识条目详情
            knowledge_map = {}
            knowledge_items = db.query(Knowledge).filter(Knowledge.id.in_(knowledge_ids)).all()
            for item in knowledge_items:
                knowledge_map[item.id] = item
            
            # 按相关性排序构建结果
            formatted_results = []
            for result in vector_results:
                knowledge_id = int(result["metadata"]["knowledge_id"])
                if knowledge_id in knowledge_map:
                    item = knowledge_map[knowledge_id]
                    
                    # 提取摘要或内容片段
                    content = item.content
                    summary = item.summary
                    
                    # 优先使用摘要，如果没有则从内容中提取
                    context = summary if summary else (
                        content[:500] + "..." if len(content) > 500 else content
                    )
                    
                    formatted_results.append({
                        "id": item.id,
                        "title": item.title,
                        "content": context,
                        "relevance": result["score"]  # 使用向量搜索的相似度分数
                    })
            
            return formatted_results
    
    # 如果未启用向量搜索或向量搜索无结果，回退到传统搜索
    search_term = f"%{query}%"
    
    # 查询相关知识条目
    results = db.query(
        Knowledge.id,
        Knowledge.title,
        Knowledge.content,
        Knowledge.summary
    ).filter(
        Knowledge.organization_id == organization_id,
        Knowledge.status == "published",
        or_(
            Knowledge.title.ilike(search_term),
            Knowledge.content.ilike(search_term),
            Knowledge.summary.ilike(search_term)
        )
    ).order_by(
        desc(
            # 简单相关性评分：标题匹配权重高于内容
            (func.position(func.lower(query), func.lower(Knowledge.title)) > 0) * 3 +
            (func.position(func.lower(query), func.lower(Knowledge.content)) > 0) * 1
        )
    ).limit(limit).all()
    
    # 格式化结果
    formatted_results = []
    for result in results:
        # 提取匹配的片段作为上下文
        content = result.content
        summary = result.summary
        
        # 优先使用摘要，如果没有则从内容中提取
        context = summary if summary else (
            content[:500] + "..." if len(content) > 500 else content
        )
        
        formatted_results.append({
            "id": result.id,
            "title": result.title,
            "content": context,
            "relevance": 0.8  # 简单实现，固定相关性分数
        })
    
    return formatted_results
```

### 3. OCR服务实现

添加OCR处理功能：

```python:backend/requirements.txt
# ... existing dependencies ...
pytesseract==0.3.10
pdf2image==1.16.3
Pillow==9.5.0
```

```python:backend/app/services/ocr_service.py
from typing import Optional, Dict, List
import os
import io
import tempfile
import pytesseract
from PIL import Image
from pdf2image import convert_from_path
import logging

logger = logging.getLogger(__name__)

def extract_text_from_image(image_path: str) -> str:
    """从图片中提取文本"""
    try:
        # 打开图片
        image = Image.open(image_path)
        
        # OCR处理
        text = pytesseract.image_to_string(image, lang='chi_sim+eng')  # 支持中文和英文
        
        return text.strip()
    except Exception as e:
        logger.error(f"Error extracting text from image: {e}")
        return ""

def extract_text_from_pdf(pdf_path: str) -> str:
    """从PDF中提取文本"""
    try:
        # 将PDF转换为图片
        with tempfile.TemporaryDirectory() as temp_dir:
            # 转换PDF页面为图片
            pages = convert_from_path(pdf_path, dpi=300)
            
            # 提取每页文本
            text_content = []
            for i, page in enumerate(pages):
                # 保存页面为临时图片
                temp_image = os.path.join(temp_dir, f"page_{i}.jpg")
                page.save(temp_image, 'JPEG')
                
                # 提取文本
                page_text = extract_text_from_image(temp_image)
                text_content.append(page_text)
            
            # 合并所有页面文本
            return "\n\n".join(text_content)
    except Exception as e:
        logger.error(f"Error extracting text from PDF: {e}")
        return ""

def extract_text_from_file(file_path: str, file_type: str) -> Optional[str]:
    """根据文件类型提取文本"""
    file_type = file_type.lower()
    
    # 图片文件
    if file_type in ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp']:
        return extract_text_from_image(file_path)
    
    # PDF文件
    elif file_type == 'application/pdf':
        return extract_text_from_pdf(file_path)
    
    # 不支持的文件类型
    else:
        logger.warning(f"Unsupported file type for OCR: {file_type}")
        return None
```

### 4. 知识自动分类服务

```python:backend/app/services/auto_categorization.py
from typing import List, Dict, Tuple, Optional
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sqlalchemy.orm import Session

from app.models.category import Category
from app.models.knowledge import Knowledge
from app.services.vector_db import vector_db_service

def get_category_embeddings(db: Session) -> Dict[int, List[float]]:
    """获取所有分类的向量表示"""
    categories = db.query(Category).all()
    category_embeddings = {}
    
    for category in categories:
        # 结合分类名称和描述
        text = category.name
        if category.description:
            text += " " + category.description
        
        # 生成嵌入向量
        embedding = vector_db_service.generate_embedding(text)
        category_embeddings[category.id] = embedding
    
    return category_embeddings

def suggest_categories(db: Session, content: str, organization_id: int, top_k: int = 3) -> List[Tuple[int, float]]:
    """
    为内容推荐最佳匹配的分类
    返回: [(category_id, similarity_score), ...]
    """
    # 过滤该组织的分类
    categories = db.query(Category).filter(Category.organization_id == organization_id).all()
    
    if not categories:
        return []
    
    # 为内容生成向量
    content_embedding = vector_db_service.generate_embedding(content)
    
    # 计算与各分类的相似度
    similarities = []
    for category in categories:
        # 结合分类名称和描述
        text = category.name
        if category.description:
            text += " " + category.description
        
        # 生成分类嵌入向量
        category_embedding = vector_db_service.generate_embedding(text)
        
        # 计算余弦相似度
        similarity = cosine_similarity(
            [content_embedding], 
            [category_embedding]
        )[0][0]
        
        similarities.append((category.id, similarity))
    
    # 按相似度降序排序并返回前top_k个
    similarities.sort(key=lambda x: x[1], reverse=True)
    return similarities[:top_k]

def auto_categorize_knowledge(db: Session, knowledge_id: int) -> Optional[int]:
    """
    自动为知识条目分配最佳匹配的分类
    返回: 分配的分类ID
    """
    knowledge = db.query(Knowledge).filter(Knowledge.id == knowledge_id).first()
    if not knowledge:
        return None
    
    # 结合标题和内容
    content = knowledge.title
    if knowledge.content:
        content += " " + knowledge.content
    
    # 获取推荐分类
    category_suggestions = suggest_categories(
        db, 
        content, 
        knowledge.organization_id,
        top_k=1  # 只取最匹配的分类
    )
    
    if not category_suggestions:
        return None
    
    best_category_id, similarity = category_suggestions[0]
    
    # 如果相似度超过阈值，分配该分类
    if similarity > 0.6:  # 可调整的阈值
        knowledge.category_id = best_category_id
        db.commit()
        return best_category_id
    
    return None
```

修改knowledge API，集成向量化和自动分类功能：

```python:backend/app/api/api_v1/endpoints/knowledge.py
# ... existing code ...
from app.services.knowledge_vectorize import vectorize_knowledge, delete_knowledge_vector
from app.services.auto_categorization import auto_categorize_knowledge, suggest_categories
from app.services.ocr_service import extract_text_from_file

@router.post("/", response_model=schemas.Knowledge)
def create_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    knowledge_in: schemas.KnowledgeCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新知识条目。
    """
    # ... existing code ...
    
    # 如果未指定分类，尝试自动分类
    if not knowledge_in.category_id and knowledge_in.content:
        category_suggestions = suggest_categories(
            db, 
            knowledge_in.title + " " + knowledge_in.content,
            knowledge_in.organization_id
        )
        if category_suggestions:
            # 使用最匹配的分类
            knowledge_in.category_id = category_suggestions[0][0]
    
    # 创建知识条目
    knowledge = crud.knowledge.create_with_tags(
        db=db, 
        obj_in=knowledge_in, 
        creator_id=current_user.id,
        tag_ids=tag_ids
    )
    
    # 如果是已发布状态，添加到向量数据库
    if knowledge.status == "published":
        vectorize_knowledge(knowledge.id, db)
    
    return knowledge

@router.put("/{id}", response_model=schemas.Knowledge)
def update_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    knowledge_in: schemas.KnowledgeUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新知识条目。
    """
    # ... existing code ...
    
    # 获取更新前的状态
    old_status = knowledge.status
    
    # 更新知识条目
    knowledge = crud.knowledge.update_with_tags(
        db=db, 
        db_obj=knowledge, 
        obj_in=knowledge_in,
        last_editor_id=current_user.id
    )
    
    # 处理向量数据库更新
    if knowledge.status == "published":
        # 如果新状态是已发布，更新向量
        vectorize_knowledge(knowledge.id, db)
    elif old_status == "published" and knowledge.status != "published":
        # 如果从已发布变为其他状态，删除向量
        delete_knowledge_vector(knowledge.id)
    
    return knowledge

@router.delete("/{id}", response_model=schemas.Knowledge)
def delete_knowledge(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除知识条目。
    """
    # ... existing code ...
    
    # 从向量数据库中删除
    delete_knowledge_vector(id)
    
    knowledge = crud.knowledge.remove(db=db, id=id)
    return knowledge

@router.post("/{id}/attachments", response_model=schemas.Attachment)
def upload_attachment(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    file: UploadFile = File(...),
    extract_text: bool = Form(False),  # 添加提取文本选项
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    上传知识条目附件。
    """
    # ... existing code ...
    
    # 保存文件
    file_path, file_size = save_upload_file(file, f"knowledge_{id}")
    
    # 创建附件记录
    attachment_in = schemas.AttachmentCreate(
        filename=file.filename,
        file_path=file_path,
        file_size=file_size,
        file_type=file.content_type,
        knowledge_id=id
    )
    attachment = crud.attachment.create_with_uploader(
        db=db, 
        obj_in=attachment_in, 
        uploader_id=current_user.id
    )
    
    # 如果需要提取文本
    if extract_text:
        # 获取完整文件路径
        full_path = os.path.join(settings.UPLOAD_DIR, file_path)
        
        # 提取文本
        extracted_text = extract_text_from_file(full_path, file.content_type)
        
        if extracted_text:
            # 获取知识条目
            knowledge = crud.knowledge.get(db=db, id=id)
            
            # 更新内容
            if knowledge.content:
                updated_content = knowledge.content + "\n\n" + extracted_text
            else:
                updated_content = extracted_text
            
            # 更新知识条目
            knowledge = crud.knowledge.update(
                db=db,
                db_obj=knowledge,
                obj_in={"content": updated_content}
            )
            
            # 如果是已发布状态，更新向量
            if knowledge.status == "published":
                vectorize_knowledge(knowledge.id, db)
    
    return attachment
```

添加自动分类API：

```python:backend/app/api/api_v1/endpoints/categorization.py
from typing import Any, List, Dict

from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps
from app.services.auto_categorization import suggest_categories, auto_categorize_knowledge

router = APIRouter()

@router.post("/suggest", response_model=List[Dict[str, Any]])
def suggest_categories_for_content(
    *,
    db: Session = Depends(deps.get_db),
    content: str = Body(..., embed=True),
    organization_id: int = Body(None, embed=True),
    top_k: int = Body(3, embed=True),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    为内容推荐分类。
    """
    # 如果未指定组织ID，使用用户所属组织
    if not organization_id:
        organization_id = current_user.organization_id
    
    # 验证权限
    if organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此组织的分类")
    
    # 获取分类建议
    suggestions = suggest_categories(db, content, organization_id, top_k)
    
    # 构建响应
    result = []
    for category_id, similarity in suggestions:
        category = crud.category.get(db, id=category_id)
        if category:
            result.append({
                "id": category.id,
                "name": category.name,
                "similarity": float(similarity)  # 确保JSON可序列化
            })
    
    return result

@router.post("/{knowledge_id}/auto-categorize", response_model=Dict[str, Any])
def auto_categorize_knowledge_item(
    *,
    db: Session = Depends(deps.get_db),
    knowledge_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    自动为知识条目分配分类。
    """
    # 验证权限
    knowledge = crud.knowledge.get(db=db, id=knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权修改此知识条目")
    
    # 执行自动分类
    category_id = auto_categorize_knowledge(db, knowledge_id)
    
    if category_id:
        category = crud.category.get(db, id=category_id)
        return {
            "success": True,
            "category_id": category_id,
            "category_name": category.name if category else None
        }
    else:
        return {
            "success": False,
            "message": "没有找到合适的分类"
        }
```

## 二、大语言模型优化

### 1. 多模型切换功能

首先，创建模型配置模型：

```python:backend/app/models/llm_model.py
from sqlalchemy import Column, Integer, String, Text, Boolean, Float, DateTime, JSON
from sqlalchemy.sql import func

from app.db.base_class import Base

class LLMModel(Base):
    """大语言模型配置"""
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), index=True, nullable=False)
    provider = Column(String(50), nullable=False)  # openai, azure, anthropic, etc.
    model_id = Column(String(100), nullable=False)  # gpt-4, gpt-3.5-turbo, claude-2, etc.
    api_key = Column(String(255), nullable=True)  # 如果每个模型使用不同的API密钥
    api_endpoint = Column(String(255), nullable=True)
    api_version = Column(String(50), nullable=True)
    
    # 模型参数
    max_tokens = Column(Integer, default=4096)
    temperature = Column(Float, default=0.7)
    top_p = Column(Float, default=1.0)
    frequency_penalty = Column(Float, default=0.0)
    presence_penalty = Column(Float, default=0.0)
    additional_params = Column(JSON, nullable=True)
    
    # 系统设置
    is_default = Column(Boolean, default=False)
    is_active = Column(Boolean, default=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

创建模型Schema：

```python:backend/app/schemas/llm_model.py
from typing import Optional, Dict, Any
from datetime import datetime
from pydantic import BaseModel, validator
import json

class LLMModelBase(BaseModel):
    name: str
    provider: str
    model_id: str
    api_key: Optional[str] = None
    api_endpoint: Optional[str] = None
    api_version: Optional[str] = None
    max_tokens: Optional[int] = 4096
    temperature: Optional[float] = 0.7
    top_p: Optional[float] = 1.0
    frequency_penalty: Optional[float] = 0.0
    presence_penalty: Optional[float] = 0.0
    additional_params: Optional[Dict[str, Any]] = None
    is_default: Optional[bool] = False
    is_active: Optional[bool] = True

class LLMModelCreate(LLMModelBase):
    pass

class LLMModelUpdate(BaseModel):
    name: Optional[str] = None
    provider: Optional[str] = None
    model_id: Optional[str] = None
    api_key: Optional[str] = None
    api_endpoint: Optional[str] = None
    api_version: Optional[str] = None
    max_tokens: Optional[int] = None
    temperature: Optional[float] = None
    top_p: Optional[float] = None
    frequency_penalty: Optional[float] = None
    presence_penalty: Optional[float] = None
    additional_params: Optional[Dict[str, Any]] = None
    is_default: Optional[bool] = None
    is_active: Optional[bool] = None

class LLMModelInDBBase(LLMModelBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class LLMModel(LLMModelInDBBase):
    # API响应中不返回API密钥
    api_key: Optional[str] = None
```

重构大语言模型服务，支持多模型：

```python:backend/app/services/llm_service.py
from typing import List, Dict, Any, Optional, Tuple, AsyncGenerator, Union
import httpx
import json
import asyncio
from sqlalchemy.orm import Session
import logging

from app.core.config import settings
from app.models.llm_model import LLMModel

logger = logging.getLogger(__name__)

class LLMService:
    """大语言模型服务，支持多模型切换"""
    
    def __init__(self):
        self.models_cache = {}  # 缓存模型配置
        self.default_model_id = None
    
    def _get_model_config(self, db: Session, model_id: Optional[int] = None) -> Optional[Dict[str, Any]]:
        """获取模型配置"""
        # 检查缓存
        if model_id and model_id in self.models_cache:
            return self.models_cache[model_id]
        
        # 查询数据库获取模型配置
        if model_id:
            model = db.query(LLMModel).filter(
                LLMModel.id == model_id,
                LLMModel.is_active == True
            ).first()
        else:
            # 获取默认模型
            model = db.query(LLMModel).filter(
                LLMModel.is_default == True,
                LLMModel.is_active == True
            ).first()
            
            # 如果没有默认模型，获取第一个激活模型
            if not model:
                model = db.query(LLMModel).filter(
                    LLMModel.is_active == True
                ).first()
        
        if not model:
            logger.error("No active model found")
            return None
        
        # 构建配置
        config = {
            "id": model.id,
            "name": model.name,
            "provider": model.provider,
            "model_id": model.model_id,
            "api_key": model.api_key or settings.OPENAI_API_KEY,  # 回退到全局设置
            "api_endpoint": model.api_endpoint or settings.OPENAI_API_ENDPOINT,
            "api_version": model.api_version,
            "max_tokens": model.max_tokens,
            "temperature": model.temperature,
            "top_p": model.top_p,
            "frequency_penalty": model.frequency_penalty,
            "presence_penalty": model.presence_penalty,
            "additional_params": model.additional_params or {}
        }
        
        # 缓存配置
        self.models_cache[model.id] = config
        
        return config
    
    async def get_completion(
        self,
        db: Session,
        messages: List[Dict[str, str]],
        model_id: Optional[int] = None,
        stream: bool = False,
        custom_params: Optional[Dict[str, Any]] = None
    ) -> Union[Tuple[str, int], AsyncGenerator[str, None]]:
        """
        获取大语言模型的回复。
        支持不同提供商的模型。
        """
        # 获取模型配置
        config = self._get_model_config(db, model_id)
        if not config:
            raise ValueError("No model configuration available")
        
        # 合并自定义参数
        params = {
            "temperature": config["temperature"],
            "top_p": config["top_p"],
            "max_tokens": config["max_tokens"],
            "frequency_penalty": config["frequency_penalty"],
            "presence_penalty": config["presence_penalty"],
            **config["additional_params"]
        }
        
        if custom_params:
            params.update(custom_params)
        
        # 根据不同提供商构建请求
        if config["provider"] == "openai":
            return await self._openai_completion(config, messages, params, stream)
        elif config["provider"] == "anthropic":
            return await self._anthropic_completion(config, messages, params, stream)
        elif config["provider"] == "azure":
            return await self._azure_openai_completion(config, messages, params, stream)
        else:
            raise ValueError(f"Unsupported model provider: {config['provider']}")
    
    async def _openai_completion(
        self, 
        config: Dict[str, Any], 
        messages: List[Dict[str, str]], 
        params: Dict[str, Any],
        stream: bool
    ) -> Union[Tuple[str, int], AsyncGenerator[str, None]]:
        """OpenAI API调用"""
        headers = {
            "Authorization

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统优化功能

## 二、大语言模型优化(续)

### 1. 多模型切换功能(续)

```python:backend/app/services/llm_service.py
    async def _openai_completion(
        self, 
        config: Dict[str, Any], 
        messages: List[Dict[str, str]], 
        params: Dict[str, Any],
        stream: bool
    ) -> Union[Tuple[str, int], AsyncGenerator[str, None]]:
        """OpenAI API调用"""
        headers = {
            "Authorization": f"Bearer {config['api_key']}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": config["model_id"],
            "messages": messages,
            "stream": stream,
            **params
        }
        
        # 流式响应
        if stream:
            async def stream_response():
                async with httpx.AsyncClient(timeout=60.0) as client:
                    async with client.stream(
                        "POST", 
                        config["api_endpoint"], 
                        headers=headers, 
                        json=payload
                    ) as response:
                        if response.status_code != 200:
                            error_detail = await response.text()
                            logger.error(f"OpenAI API error: {error_detail}")
                            raise Exception(f"API请求失败: {error_detail}")
                        
                        # 处理流式响应
                        buffer = ""
                        async for chunk in response.aiter_text():
                            if chunk.startswith("data: "):
                                chunk = chunk[6:]
                            if chunk.strip() == "[DONE]":
                                continue
                            try:
                                data = json.loads(chunk)
                                content = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
                                if content:
                                    buffer += content
                                    yield content
                            except json.JSONDecodeError:
                                pass
            
            return stream_response()
        
        # 非流式响应
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(config["api_endpoint"], headers=headers, json=payload)
            
            if response.status_code != 200:
                logger.error(f"OpenAI API error: {response.text}")
                raise Exception(f"API请求失败: {response.text}")
            
            result = response.json()
            message = result["choices"][0]["message"]["content"]
            tokens = result["usage"]["total_tokens"]
            
            return message, tokens
    
    async def _anthropic_completion(
        self, 
        config: Dict[str, Any], 
        messages: List[Dict[str, str]], 
        params: Dict[str, Any],
        stream: bool
    ) -> Union[Tuple[str, int], AsyncGenerator[str, None]]:
        """Anthropic Claude API调用"""
        headers = {
            "x-api-key": config["api_key"],
            "Content-Type": "application/json",
            "anthropic-version": "2023-06-01"
        }
        
        # 将OpenAI格式的消息转换为Anthropic格式
        system_message = next((m["content"] for m in messages if m["role"] == "system"), None)
        human_assistant_messages = [m for m in messages if m["role"] in ["user", "assistant"]]
        
        # 构建Anthropic消息格式
        anthropic_messages = []
        for msg in human_assistant_messages:
            role = "human" if msg["role"] == "user" else "assistant"
            anthropic_messages.append({"role": role, "content": msg["content"]})
        
        payload = {
            "model": config["model_id"],
            "messages": anthropic_messages,
            "system": system_message,
            "stream": stream,
            "max_tokens": params.get("max_tokens", 4096),
            "temperature": params.get("temperature", 0.7),
            "top_p": params.get("top_p", 1.0),
        }
        
        endpoint = config["api_endpoint"] or "https://api.anthropic.com/v1/messages"
        
        # 流式响应
        if stream:
            async def stream_response():
                async with httpx.AsyncClient(timeout=90.0) as client:
                    async with client.stream(
                        "POST", 
                        endpoint, 
                        headers=headers, 
                        json=payload
                    ) as response:
                        if response.status_code != 200:
                            error_detail = await response.text()
                            logger.error(f"Anthropic API error: {error_detail}")
                            raise Exception(f"API请求失败: {error_detail}")
                        
                        async for chunk in response.aiter_text():
                            try:
                                if chunk.startswith("data: "):
                                    chunk = chunk[6:]
                                if chunk.strip() == "[DONE]":
                                    continue
                                    
                                data = json.loads(chunk)
                                delta = data.get("delta", {})
                                if delta.get("type") == "text_delta":
                                    content = delta.get("text", "")
                                    if content:
                                        yield content
                            except json.JSONDecodeError:
                                pass
            
            return stream_response()
        
        # 非流式响应
        async with httpx.AsyncClient(timeout=90.0) as client:
            response = await client.post(endpoint, headers=headers, json=payload)
            
            if response.status_code != 200:
                logger.error(f"Anthropic API error: {response.text}")
                raise Exception(f"API请求失败: {response.text}")
            
            result = response.json()
            message = result["content"][0]["text"]
            
            # Anthropic API不返回token数量，估算
            tokens = len(message) // 4  # 粗略估计
            
            return message, tokens
    
    async def _azure_openai_completion(
        self, 
        config: Dict[str, Any], 
        messages: List[Dict[str, str]], 
        params: Dict[str, Any],
        stream: bool
    ) -> Union[Tuple[str, int], AsyncGenerator[str, None]]:
        """Azure OpenAI API调用"""
        # Azure OpenAI需要API密钥作为auth header
        headers = {
            "api-key": config["api_key"],
            "Content-Type": "application/json"
        }
        
        # 构建完整的端点URL
        deployment_id = config["model_id"]
        api_version = config["api_version"] or "2023-05-15"
        endpoint = f"{config['api_endpoint']}/openai/deployments/{deployment_id}/chat/completions?api-version={api_version}"
        
        payload = {
            "messages": messages,
            "stream": stream,
            **params
        }
        
        # 流式响应
        if stream:
            async def stream_response():
                async with httpx.AsyncClient(timeout=60.0) as client:
                    async with client.stream(
                        "POST", 
                        endpoint, 
                        headers=headers, 
                        json=payload
                    ) as response:
                        if response.status_code != 200:
                            error_detail = await response.text()
                            logger.error(f"Azure OpenAI API error: {error_detail}")
                            raise Exception(f"API请求失败: {error_detail}")
                        
                        # 处理流式响应
                        buffer = ""
                        async for chunk in response.aiter_text():
                            if chunk.startswith("data: "):
                                chunk = chunk[6:]
                            if chunk.strip() == "[DONE]":
                                continue
                            try:
                                data = json.loads(chunk)
                                content = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
                                if content:
                                    buffer += content
                                    yield content
                            except json.JSONDecodeError:
                                pass
            
            return stream_response()
        
        # 非流式响应
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(endpoint, headers=headers, json=payload)
            
            if response.status_code != 200:
                logger.error(f"Azure OpenAI API error: {response.text}")
                raise Exception(f"API请求失败: {response.text}")
            
            result = response.json()
            message = result["choices"][0]["message"]["content"]
            tokens = result["usage"]["total_tokens"]
            
            return message, tokens

# 创建LLM服务实例
llm_service = LLMService()
```

修改现有的chat服务，支持模型选择：

```python:backend/app/api/api_v1/endpoints/chat.py
# ... existing imports ...
from app.services.llm_service import llm_service

# ... existing code ...

@router.post("/completion", response_model=schemas.ChatCompletionResponse)
async def chat_completion(
    *,
    db: Session = Depends(deps.get_db),
    request: schemas.ChatCompletionRequest,
    background_tasks: BackgroundTasks,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    发送消息并获取AI回复。
    """
    # ... existing code for handling chat ...
    
    # 获取聊天历史
    chat_history = crud.chat_message.get_chat_history(db=db, chat_id=chat_id)
    
    # 搜索相关知识
    knowledge_results = search_knowledge(
        db=db, 
        query=request.message, 
        organization_id=current_user.organization_id,
        use_vector_search=True  # 启用向量搜索
    )
    
    # 构建知识上下文
    knowledge_context = ""
    knowledge_sources = []
    if knowledge_results:
        for result in knowledge_results:
            knowledge_context += f"\n---\n{result['content']}\n"
            knowledge_sources.append({
                "id": result["id"],
                "title": result["title"],
                "relevance": result["relevance"]
            })
    
    # 构建系统提示
    system_prompt = "你是一个企业智能知识库助手，请根据提供的知识信息回答问题。如果没有足够信息，请诚实地说明你不知道，不要编造答案。"
    
    if knowledge_context:
        system_prompt += "\n\n以下是与用户问题相关的知识库内容，请参考这些内容回答问题：\n" + knowledge_context
    
    # 构建消息历史
    messages = [{"role": "system", "content": system_prompt}]
    
    # 添加历史消息（最多5轮对话）
    recent_history = chat_history[-10:] if len(chat_history) > 10 else chat_history
    for msg in recent_history:
        messages.append({"role": msg["role"], "content": msg["content"]})
    
    # 添加当前用户消息
    messages.append({"role": "user", "content": request.message})
    
    # 如果是流式响应
    if request.stream:
        return StreamingResponse(
            llm_service.get_completion(
                db=db,
                messages=messages,
                model_id=request.model_id,  # 添加模型ID参数
                stream=True
            ),
            media_type="text/event-stream"
        )
    
    # 非流式响应
    ai_response, tokens = await llm_service.get_completion(
        db=db,
        messages=messages,
        model_id=request.model_id  # 添加模型ID参数
    )
    
    # ... existing code for saving response ...
```

### 2. 模型管理API

```python:backend/app/api/api_v1/endpoints/llm_models.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps
from app.models.llm_model import LLMModel
from app.services.llm_service import llm_service

router = APIRouter()

@router.get("/", response_model=List[schemas.LLMModel])
def read_models(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取LLM模型列表。
    """
    # 只有管理员可以查看所有模型配置
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    models_list = db.query(LLMModel).offset(skip).limit(limit).all()
    return models_list

@router.post("/", response_model=schemas.LLMModel)
def create_model(
    *,
    db: Session = Depends(deps.get_db),
    model_in: schemas.LLMModelCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新的LLM模型配置。
    """
    # 只有管理员可以创建模型配置
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 如果新模型设置为默认，将其他模型设置为非默认
    if model_in.is_default:
        db.query(LLMModel).filter(LLMModel.is_default == True).update({"is_default": False})
    
    # 创建模型
    db_model = LLMModel(**model_in.dict())
    db.add(db_model)
    db.commit()
    db.refresh(db_model)
    
    # 清除LLM服务的模型缓存
    if hasattr(llm_service, "models_cache"):
        llm_service.models_cache = {}
    
    return db_model

@router.get("/{id}", response_model=schemas.LLMModel)
def read_model(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取LLM模型详情。
    """
    # 只有管理员可以查看模型配置详情
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    model = db.query(LLMModel).filter(LLMModel.id == id).first()
    if not model:
        raise HTTPException(status_code=404, detail="模型不存在")
    
    return model

@router.put("/{id}", response_model=schemas.LLMModel)
def update_model(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    model_in: schemas.LLMModelUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新LLM模型配置。
    """
    # 只有管理员可以更新模型配置
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    model = db.query(LLMModel).filter(LLMModel.id == id).first()
    if not model:
        raise HTTPException(status_code=404, detail="模型不存在")
    
    # 如果要将此模型设为默认，将其他模型设置为非默认
    if model_in.is_default:
        db.query(LLMModel).filter(LLMModel.id != id, LLMModel.is_default == True).update({"is_default": False})
    
    # 更新模型属性
    model_data = model_in.dict(exclude_unset=True)
    for key, value in model_data.items():
        setattr(model, key, value)
    
    db.commit()
    db.refresh(model)
    
    # 清除LLM服务的模型缓存
    if hasattr(llm_service, "models_cache"):
        llm_service.models_cache = {}
    
    return model

@router.delete("/{id}", response_model=schemas.LLMModel)
def delete_model(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除LLM模型配置。
    """
    # 只有管理员可以删除模型配置
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    model = db.query(LLMModel).filter(LLMModel.id == id).first()
    if not model:
        raise HTTPException(status_code=404, detail="模型不存在")
    
    # 不允许删除默认模型
    if model.is_default:
        raise HTTPException(status_code=400, detail="不能删除默认模型，请先设置另一个模型为默认")
    
    # 删除模型
    db.delete(model)
    db.commit()
    
    # 清除LLM服务的模型缓存
    if hasattr(llm_service, "models_cache"):
        llm_service.models_cache = {}
    
    return model

@router.post("/{id}/test", response_model=dict)
async def test_model(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    message: str,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    测试LLM模型响应。
    """
    # 只有管理员可以测试模型
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    model = db.query(LLMModel).filter(LLMModel.id == id).first()
    if not model:
        raise HTTPException(status_code=404, detail="模型不存在")
    
    if not model.is_active:
        raise HTTPException(status_code=400, detail="模型未激活")
    
    try:
        # 构建测试消息
        messages = [
            {"role": "system", "content": "你是一个有用的AI助手。"},
            {"role": "user", "content": message}
        ]
        
        # 获取模型响应
        response, tokens = await llm_service.get_completion(
            db=db,
            messages=messages,
            model_id=id
        )
        
        return {
            "success": True,
            "model_id": id,
            "model_name": model.name,
            "response": response,
            "tokens": tokens
        }
    except Exception as e:
        return {
            "success": False,
            "model_id": id,
            "model_name": model.name,
            "error": str(e)
        }

@router.post("/{id}/set-default", response_model=schemas.LLMModel)
def set_default_model(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    设置默认LLM模型。
    """
    # 只有管理员可以设置默认模型
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="权限不足")
    
    model = db.query(LLMModel).filter(LLMModel.id == id).first()
    if not model:
        raise HTTPException(status_code=404, detail="模型不存在")
    
    if not model.is_active:
        raise HTTPException(status_code=400, detail="无法将未激活的模型设为默认")
    
    # 将其他模型设置为非默认
    db.query(LLMModel).filter(LLMModel.id != id).update({"is_default": False})
    
    # 设置当前模型为默认
    model.is_default = True
    db.commit()
    db.refresh(model)
    
    # 清除LLM服务的模型缓存
    if hasattr(llm_service, "models_cache"):
        llm_service.models_cache = {}
    
    return model
```

### 3. 模型微调功能

```python:backend/app/models/fine_tune.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Float
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base_class import Base

class FineTuneData(Base):
    """模型微调数据集"""
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), index=True, nullable=False)
    description = Column(Text, nullable=True)
    data_file = Column(String(500), nullable=False)  # JSONL文件路径
    format = Column(String(50), default="chat")  # chat, completion等
    num_examples = Column(Integer, default=0)
    
    # 关系
    creator_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    creator = relationship("User", foreign_keys=[creator_id])
    organization_id = Column(Integer, ForeignKey("organization.id"), nullable=False)
    organization = relationship("Organization")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class FineTuneJob(Base):
    """模型微调任务"""
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), index=True, nullable=False)
    description = Column(Text, nullable=True)
    base_model = Column(String(100), nullable=False)  # 基础模型ID
    provider = Column(String(50), nullable=False)  # openai, azure等
    job_id = Column(String(100), nullable=True)  # 提供商返回的任务ID
    
    # 微调参数
    learning_rate = Column(Float, nullable=True)
    epochs = Column(Integer, nullable=True)
    batch_size = Column(Integer, nullable=True)
    
    # 状态信息
    status = Column(String(50), default="pending")  # pending, running, completed, failed
    fine_tuned_model = Column(String(100), nullable=True)  # 微调后的模型ID
    error_message = Column(Text, nullable=True)
    
    # 关系
    dataset_id = Column(Integer, ForeignKey("fine_tune_data.id"), nullable=False)
    dataset = relationship("FineTuneData")
    
    creator_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    creator = relationship("User", foreign_keys=[creator_id])
    
    organization_id = Column(Integer, ForeignKey("organization.id"), nullable=False)
    organization = relationship("Organization")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
```

添加微调Schema:

```python:backend/app/schemas/fine_tune.py
from typing import Optional, List, Dict, Any
from datetime import datetime
from pydantic import BaseModel

# 数据集相关Schema
class FineTuneDataBase(BaseModel):
    name: str
    description: Optional[str] = None
    format: str = "chat"

class FineTuneDataCreate(FineTuneDataBase):
    organization_id: int

class FineTuneDataUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None

class FineTuneDataInDBBase(FineTuneDataBase):
    id: int
    data_file: str
    num_examples: int
    creator_id: int
    organization_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class FineTuneData(FineTuneDataInDBBase):
    pass

# 微调任务相关Schema
class FineTuneJobBase(BaseModel):
    name: str
    description: Optional[str] = None
    base_model: str
    provider: str
    dataset_id: int
    learning_rate: Optional[float] = None
    epochs: Optional[int] = None
    batch_size: Optional[int] = None

class FineTuneJobCreate(FineTuneJobBase):
    organization_id: int

class FineTuneJobUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    status: Optional[str] = None
    fine_tuned_model: Optional[str] = None
    error_message: Optional[str] = None

class FineTuneJobInDBBase(FineTuneJobBase):
    id: int
    job_id: Optional[str] = None
    status: str
    fine_tuned_model: Optional[str] = None
    error_message: Optional[str] = None
    creator_id: int
    organization_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class FineTuneJob(FineTuneJobInDBBase):
    dataset: FineTuneData
```

微调服务实现：

```python:backend/app/services/fine_tune_service.py
from typing import List, Dict, Any, Optional, BinaryIO
import os
import json
import uuid
import httpx
from datetime import datetime
import logging
from sqlalchemy.orm import Session

from app.models.fine_tune import FineTuneData, FineTuneJob
from app.core.config import settings
from app.utils.file_storage import ensure_dir_exists

logger = logging.getLogger(__name__)

class FineTuneService:
    """模型微调服务"""
    
    def __init__(self):
        self.upload_dir = os.path.join(settings.UPLOAD_DIR, "fine_tune_data")
        ensure_dir_exists(os.path.join(self.upload_dir))
    
    def save_training_data(self, content: str, format: str = "chat") -> str:
        """保存训练数据到文件"""
        # 生成唯一文件名
        file_id = uuid.uuid4().hex
        year_month = datetime.now().strftime("%Y/%m")
        dir_path = os.path.join(self.upload_dir, year_month)
        ensure_dir_exists(dir_path)
        
        # 构建文件路径
        file_path = os.path.join(dir_path, f"{file_id}.jsonl")
        
        # 保存文件
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        
        # 返回相对路径
        return os.path.relpath(file_path, settings.UPLOAD_DIR)
    
    def count_examples(self, file_path: str) -> int:
        """计算训练数据中的示例数量"""
        full_path = os.path.join(settings.UPLOAD_DIR, file_path)
        
        try:
            with open(full_path, "r", encoding="utf-8") as f:
                return sum(1 for _ in f)
        except Exception as e:
            logger.error(f"Error counting examples: {e}")
            return 0
    
    def validate_training_data(self, file_path: str, format: str = "chat") -> Dict[str, Any]:
        """验证训练数据格式有效性"""
        full_path = os.path.join(settings.UPLOAD_DIR, file_path)
        
        try:
            with open(full_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            
            if not lines:
                return {"valid": False, "error": "文件为空"}
            
            # 验证每行是否是有效的JSON
            for i, line in enumerate(lines):
                try:
                    data = json.loads(line.strip())
                    
                    # 验证chat格式
                    if format == "chat":
                        if "messages" not in data:
                            return {"valid": False, "error": f"第{i+1}行缺少'messages'字段"}
                        
                        if not isinstance(data["messages"], list) or len(data["messages"]) < 2:
                            return {"valid": False, "error": f"第{i+1}行'messages'字段格式无效"}
                        
                        for msg in data["messages"]:
                            if "role" not in msg or "content" not in msg:
                                return {"valid": False, "error": f"第{i+1}行消息缺少'role'或'content'字段"}
                            
                            if msg["role"] not in ["system", "user", "assistant"]:
                                return {"valid": False, "error": f"第{i+1}行消息'role'字段无效"}
                    
                    # 验证completion格式
                    elif format == "completion":
                        if "prompt" not in data or "completion" not in data:
                            return {"valid": False, "error": f"第{i+1}行缺少'prompt'或'completion'字段"}
                
                except json.JSONDecodeError:
                    return {"valid": False, "error": f"第{i+1}行不是有效的JSON"}
            
            return {"valid": True, "examples": len(lines)}
        
        except Exception as e:
            logger.error(f"Error validating training data: {e}")
            return {"valid": False, "error": str(e)}
    
    async def create_fine_tune_job(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """创建微调任务"""
        try:
            # 获取数据集
            dataset = db.query(FineTuneData).filter(FineTuneData.id == job.dataset_id).first()
            if not dataset:
                return {"success": False, "error": "数据集不存在"}
            
            # 根据提供商调用不同的API
            if job.provider == "openai":
                return await self._create_openai_fine_tune(db, job, dataset)
            elif job.provider == "azure":
                return await self._create_azure_fine_tune(db, job, dataset)
            else:
                return {"success": False, "error": f"不支持的提供商: {job.provider}"}
        
        except Exception as e:
            logger.error(f"Error creating fine-tune job: {e}")
            return {"success": False, "error": str(e)}
    
    async def _create_openai_fine_tune(self, db: Session, job: FineTuneJob, dataset: FineTuneData) -> Dict[str, Any]:
        """创建OpenAI微调任务"""
        # 构建请求数据
        api_key = settings.OPENAI_API_KEY
        training_file_path = os.path.join(settings.UPLOAD_DIR, dataset.data_file)
        
        # 第一步：上传训练文件
        files = {'file': ('training_data.jsonl', open(training_file_path, 'rb'), 'application/json')}
        headers = {'Authorization': f'Bearer {api_key}'}
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            # 上传文件
            response = await client.post(
                'https://api.openai.com/v1/files',
                headers=headers,
                files=files,
                data={'purpose': 'fine-tune'}
            )
            
            if response.status_code != 200:
                return {"success": False, "error": f"上传文件失败: {response.text}"}
            
            file_data = response.json()
            file_id = file_data['id']
            
            # 第二步：创建微调任务
            payload = {
                'training_file': file_id,
                'model': job.base_model,
                'suffix': job.name.replace(' ', '_')[:40]  # OpenAI限制后缀长度
            }
            
            # 添加可选参数
            if job.learning_rate:
                payload['learning_rate_multiplier'] = job.learning_rate
            if job.epochs:
                payload['n_epochs'] = job.epochs
            if job.batch_size:
                payload['batch_size'] = job.batch_size
            
            response = await client.post(
                'https://api.openai.com/v1/fine_tuning/jobs',
                headers=headers,
                json=payload
            )
            
            if response.status_code != 200:
                return {"success": False, "error": f"创建微调任务失败: {response.text}"}
            
            ft_data = response.json()
            
            # 更新任务状态
            job.job_id = ft_data['id']
            job.status = 'running'
            db.commit()
            
            return {
                "success": True,
                "job_id": ft_data['id'],
                "status": ft_data['status'],
                "message": "微调任务已创建"
            }
    
    async def _create_azure_fine_tune(self, db: Session, job: FineTuneJob, dataset: FineTuneData) -> Dict[str, Any]:
        """创建Azure微调任务"""
        # Azure OpenAI微调实现
        # 注意：Azure OpenAI的微调API可能与OpenAI有所不同
        return {"success": False, "error": "Azure微调功能尚未实现"}
    
    async def check_fine_tune_status(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """检查微调任务状态"""
        if not job.job_id:
            return {"success": False, "error": "微调任务ID不存在"}
        
        try:
            if job.provider == "openai":
                return await self._check_openai_fine_tune(db, job)
            elif job.provider == "azure":
                return await self._check_azure_fine_tune(db, job)
            else:
                return {"success": False, "error": f"不支持的提供商: {job.provider}"}
        
        except Exception as e:
            logger.error(f"Error checking fine-tune status: {e}")
            return {"success": False, "error": str(e)}
    
    async def _check_openai_fine_tune(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """检查OpenAI微调任务状态"""
        api_key = settings.OPENAI_API_KEY
        headers = {'Authorization': f'Bearer {api_key}'}
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.get(
                f'https://api.openai.com/v1/fine_tuning/jobs/{job.job_id}',
                headers=headers
            )
            
            if response.status_code != 200:
                return {"success": False, "error": f"获取微调状态失败: {response.text}"}
            
            data = response.json()
            
            # 更新任务状态
            job.status = data['status']
            
            # 如果任务完成，记录微调后的模型ID
            if data['status'] == 'succeeded':
                job.fine_tuned_model = data['fine_tuned_model']
                job.completed_at = datetime.now()
            
            # 如果任务失败，记录错误信息
            elif data['status'] == 'failed':
                job.error_message = data.get('error', {}).get('message', '未知错误')
            
            db.commit()
            
            return {
                "success": True,
                "status": data['status'],
                "fine_tuned_model": data.get('fine_tuned_model'),
                "error": data.get('error')
            }
    
    async def _check_azure_fine_tune(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统优化功能

## 二、大语言模型优化(续)

### 3. 模型微调功能(续)

```python:backend/app/services/fine_tune_service.py
    async def _check_azure_fine_tune(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """检查Azure微调任务状态"""
        # Azure微调状态检查的实现
        # 注意：Azure OpenAI的微调API可能与OpenAI有所不同
        return {"success": False, "error": "Azure微调状态检查功能尚未实现"}
    
    async def cancel_fine_tune_job(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """取消微调任务"""
        if not job.job_id:
            return {"success": False, "error": "微调任务ID不存在"}
        
        if job.status not in ["pending", "running"]:
            return {"success": False, "error": f"无法取消状态为{job.status}的任务"}
        
        try:
            if job.provider == "openai":
                return await self._cancel_openai_fine_tune(db, job)
            elif job.provider == "azure":
                return await self._cancel_azure_fine_tune(db, job)
            else:
                return {"success": False, "error": f"不支持的提供商: {job.provider}"}
        
        except Exception as e:
            logger.error(f"Error cancelling fine-tune job: {e}")
            return {"success": False, "error": str(e)}
    
    async def _cancel_openai_fine_tune(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """取消OpenAI微调任务"""
        api_key = settings.OPENAI_API_KEY
        headers = {'Authorization': f'Bearer {api_key}'}
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f'https://api.openai.com/v1/fine_tuning/jobs/{job.job_id}/cancel',
                headers=headers
            )
            
            if response.status_code != 200:
                return {"success": False, "error": f"取消微调任务失败: {response.text}"}
            
            data = response.json()
            
            # 更新任务状态
            job.status = data['status']
            job.error_message = "用户取消"
            db.commit()
            
            return {
                "success": True,
                "status": data['status'],
                "message": "微调任务已取消"
            }
    
    async def _cancel_azure_fine_tune(self, db: Session, job: FineTuneJob) -> Dict[str, Any]:
        """取消Azure微调任务"""
        # Azure微调取消的实现
        return {"success": False, "error": "Azure微调取消功能尚未实现"}
    
    def build_training_sample(self, prompt: str, completion: str, format: str = "chat") -> str:
        """构建训练样本"""
        if format == "chat":
            sample = {
                "messages": [
                    {"role": "user", "content": prompt},
                    {"role": "assistant", "content": completion}
                ]
            }
        elif format == "completion":
            sample = {
                "prompt": prompt,
                "completion": completion
            }
        else:
            raise ValueError(f"不支持的格式: {format}")
        
        return json.dumps(sample, ensure_ascii=False)
    
    def build_training_sample_with_system(self, system: str, prompt: str, completion: str) -> str:
        """构建带系统提示的训练样本"""
        sample = {
            "messages": [
                {"role": "system", "content": system},
                {"role": "user", "content": prompt},
                {"role": "assistant", "content": completion}
            ]
        }
        
        return json.dumps(sample, ensure_ascii=False)
    
    def generate_training_data_from_knowledge(self, db: Session, organization_id: int, limit: int = 100) -> str:
        """从知识库生成训练数据"""
        from app.models.knowledge import Knowledge
        
        # 查询已发布的知识条目
        knowledge_items = db.query(Knowledge).filter(
            Knowledge.organization_id == organization_id,
            Knowledge.status == "published"
        ).limit(limit).all()
        
        training_data = []
        
        for item in knowledge_items:
            if not item.content:
                continue
            
            # 生成"写出总结"的训练样本
            prompt = f"请为以下内容撰写一个简短的摘要：\n\n{item.title}\n\n{item.content}"
            completion = item.summary if item.summary else "这是关于" + item.title + "的内容。"
            training_data.append(self.build_training_sample(prompt, completion))
            
            # 生成"回答问题"的训练样本
            prompt = f"基于以下知识回答问题：\n\n知识：{item.title}\n\n{item.content}\n\n问题：{item.title}是什么？"
            completion = f"{item.title}是指" + (item.summary if item.summary else "...")
            training_data.append(self.build_training_sample(prompt, completion))
        
        return "\n".join(training_data)

# 创建服务实例
fine_tune_service = FineTuneService()
```

添加微调API:

```python:backend/app/api/api_v1/endpoints/fine_tune.py
from typing import Any, List, Dict, Optional

from fastapi import APIRouter, Depends, HTTPException, File, UploadFile, Form, BackgroundTasks
from sqlalchemy.orm import Session
from datetime import datetime

from app import crud, models, schemas
from app.api import deps
from app.models.fine_tune import FineTuneData, FineTuneJob
from app.services.fine_tune_service import fine_tune_service

router = APIRouter()

@router.get("/datasets", response_model=List[schemas.FineTuneData])
def read_datasets(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取微调数据集列表。
    """
    # 只有管理员可以查看所有数据集
    if current_user.is_admin:
        datasets = db.query(FineTuneData).offset(skip).limit(limit).all()
    else:
        # 普通用户只能查看自己组织的数据集
        datasets = db.query(FineTuneData).filter(
            FineTuneData.organization_id == current_user.organization_id
        ).offset(skip).limit(limit).all()
    
    return datasets

@router.post("/datasets", response_model=schemas.FineTuneData)
def create_dataset(
    *,
    db: Session = Depends(deps.get_db),
    name: str = Form(...),
    description: Optional[str] = Form(None),
    format: str = Form("chat"),
    file: UploadFile = File(...),
    organization_id: Optional[int] = Form(None),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新的微调数据集。
    """
    # 如果未指定组织ID，使用当前用户的组织ID
    if not organization_id:
        organization_id = current_user.organization_id
    
    # 验证组织权限
    if organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为其他组织创建数据集")
    
    # 读取文件内容
    content = file.file.read().decode("utf-8")
    
    # 验证训练数据格式
    validation = fine_tune_service.validate_training_data(content, format)
    if not validation["valid"]:
        raise HTTPException(status_code=400, detail=f"训练数据格式无效: {validation['error']}")
    
    # 保存训练数据
    data_file = fine_tune_service.save_training_data(content, format)
    
    # 创建数据集记录
    dataset = FineTuneData(
        name=name,
        description=description,
        format=format,
        data_file=data_file,
        num_examples=validation["examples"],
        creator_id=current_user.id,
        organization_id=organization_id,
    )
    
    db.add(dataset)
    db.commit()
    db.refresh(dataset)
    
    return dataset

@router.get("/datasets/{id}", response_model=schemas.FineTuneData)
def read_dataset(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取微调数据集详情。
    """
    dataset = db.query(FineTuneData).filter(FineTuneData.id == id).first()
    if not dataset:
        raise HTTPException(status_code=404, detail="数据集不存在")
    
    # 验证权限
    if dataset.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此数据集")
    
    return dataset

@router.delete("/datasets/{id}", response_model=schemas.FineTuneData)
def delete_dataset(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    删除微调数据集。
    """
    dataset = db.query(FineTuneData).filter(FineTuneData.id == id).first()
    if not dataset:
        raise HTTPException(status_code=404, detail="数据集不存在")
    
    # 验证权限
    if dataset.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权删除此数据集")
    
    # 检查是否有使用此数据集的微调任务
    jobs = db.query(FineTuneJob).filter(FineTuneJob.dataset_id == id).count()
    if jobs > 0:
        raise HTTPException(status_code=400, detail="此数据集已被微调任务使用，无法删除")
    
    # 删除数据集
    db.delete(dataset)
    db.commit()
    
    return dataset

@router.post("/generate-data", response_model=Dict[str, Any])
def generate_training_data(
    *,
    db: Session = Depends(deps.get_db),
    name: str,
    description: Optional[str] = None,
    format: str = "chat",
    limit: int = 100,
    organization_id: Optional[int] = None,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    从知识库生成训练数据。
    """
    # 如果未指定组织ID，使用当前用户的组织ID
    if not organization_id:
        organization_id = current_user.organization_id
    
    # 验证组织权限
    if organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为其他组织生成数据")
    
    # 生成训练数据
    content = fine_tune_service.generate_training_data_from_knowledge(db, organization_id, limit)
    
    if not content:
        raise HTTPException(status_code=400, detail="未能生成训练数据，可能是知识库为空")
    
    # 保存训练数据
    data_file = fine_tune_service.save_training_data(content, format)
    
    # 计算样本数量
    num_examples = fine_tune_service.count_examples(data_file)
    
    # 创建数据集记录
    dataset = FineTuneData(
        name=name,
        description=description,
        format=format,
        data_file=data_file,
        num_examples=num_examples,
        creator_id=current_user.id,
        organization_id=organization_id,
    )
    
    db.add(dataset)
    db.commit()
    db.refresh(dataset)
    
    return {
        "success": True,
        "dataset_id": dataset.id,
        "examples": num_examples,
        "message": f"已从知识库生成{num_examples}个训练样本"
    }

@router.get("/jobs", response_model=List[schemas.FineTuneJob])
def read_jobs(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取微调任务列表。
    """
    # 只有管理员可以查看所有任务
    if current_user.is_admin:
        jobs = db.query(FineTuneJob).offset(skip).limit(limit).all()
    else:
        # 普通用户只能查看自己组织的任务
        jobs = db.query(FineTuneJob).filter(
            FineTuneJob.organization_id == current_user.organization_id
        ).offset(skip).limit(limit).all()
    
    return jobs

@router.post("/jobs", response_model=Dict[str, Any])
async def create_job(
    *,
    db: Session = Depends(deps.get_db),
    job_data: schemas.FineTuneJobCreate,
    background_tasks: BackgroundTasks,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建新的微调任务。
    """
    # 如果未指定组织ID，使用当前用户的组织ID
    if not job_data.organization_id:
        job_data.organization_id = current_user.organization_id
    
    # 验证组织权限
    if job_data.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权为其他组织创建任务")
    
    # 验证数据集
    dataset = db.query(FineTuneData).filter(FineTuneData.id == job_data.dataset_id).first()
    if not dataset:
        raise HTTPException(status_code=404, detail="数据集不存在")
    
    if dataset.organization_id != job_data.organization_id:
        raise HTTPException(status_code=400, detail="数据集与指定组织不匹配")
    
    # 创建任务记录
    job = FineTuneJob(**job_data.dict(), creator_id=current_user.id, status="pending")
    db.add(job)
    db.commit()
    db.refresh(job)
    
    # 在后台启动微调任务
    async def start_fine_tune():
        result = await fine_tune_service.create_fine_tune_job(db, job)
        if not result["success"]:
            # 更新任务状态为失败
            job.status = "failed"
            job.error_message = result["error"]
            db.commit()
    
    background_tasks.add_task(start_fine_tune)
    
    return {
        "success": True,
        "job_id": job.id,
        "message": "微调任务已创建并正在后台处理"
    }

@router.get("/jobs/{id}", response_model=schemas.FineTuneJob)
def read_job(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取微调任务详情。
    """
    job = db.query(FineTuneJob).filter(FineTuneJob.id == id).first()
    if not job:
        raise HTTPException(status_code=404, detail="任务不存在")
    
    # 验证权限
    if job.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此任务")
    
    return job

@router.post("/jobs/{id}/check", response_model=Dict[str, Any])
async def check_job_status(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    检查微调任务状态。
    """
    job = db.query(FineTuneJob).filter(FineTuneJob.id == id).first()
    if not job:
        raise HTTPException(status_code=404, detail="任务不存在")
    
    # 验证权限
    if job.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此任务")
    
    # 检查状态
    result = await fine_tune_service.check_fine_tune_status(db, job)
    
    return result

@router.post("/jobs/{id}/cancel", response_model=Dict[str, Any])
async def cancel_job(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    取消微调任务。
    """
    job = db.query(FineTuneJob).filter(FineTuneJob.id == id).first()
    if not job:
        raise HTTPException(status_code=404, detail="任务不存在")
    
    # 验证权限
    if job.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权取消此任务")
    
    # 取消任务
    result = await fine_tune_service.cancel_fine_tune_job(db, job)
    
    return result
```

## 三、知识管理功能扩展

### 1. 知识版本控制与历史记录

首先创建版本控制模型：

```python:backend/app/models/version.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base_class import Base

class KnowledgeVersion(Base):
    """知识条目版本控制"""
    id = Column(Integer, primary_key=True, index=True)
    version_number = Column(Integer, nullable=False)
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=True)
    summary = Column(Text, nullable=True)
    status = Column(String(20), nullable=False)
    change_description = Column(String(200), nullable=True)
    
    # 记录标签变更（JSON格式存储历史标签）
    tags_snapshot = Column(JSON, nullable=True)
    
    # 关系
    knowledge_id = Column(Integer, ForeignKey("knowledge.id"), nullable=False)
    knowledge = relationship("Knowledge", back_populates="versions")
    
    editor_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    editor = relationship("User")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

更新Knowledge模型：

```python:backend/app/models/knowledge.py
# ... existing code ...

class Knowledge(Base):
    # ... existing code ...
    
    # 添加版本控制关系
    versions = relationship("KnowledgeVersion", back_populates="knowledge", cascade="all, delete-orphan")
    current_version = Column(Integer, default=1)
```

添加版本控制Schema：

```python:backend/app/schemas/version.py
from typing import Optional, List, Dict, Any
from datetime import datetime
from pydantic import BaseModel

class KnowledgeVersionBase(BaseModel):
    version_number: int
    title: str
    content: Optional[str] = None
    summary: Optional[str] = None
    status: str
    change_description: Optional[str] = None
    tags_snapshot: Optional[List[Dict[str, Any]]] = None

class KnowledgeVersionCreate(KnowledgeVersionBase):
    knowledge_id: int
    editor_id: int

class KnowledgeVersionInDBBase(KnowledgeVersionBase):
    id: int
    knowledge_id: int
    editor_id: int
    created_at: datetime

    class Config:
        orm_mode = True

class KnowledgeVersion(KnowledgeVersionInDBBase):
    editor: Dict[str, Any]
```

添加版本控制服务：

```python:backend/app/services/version_service.py
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
import json

from app.models.knowledge import Knowledge
from app.models.version import KnowledgeVersion
from app.models.knowledge_tag import knowledge_tag

def create_version(
    db: Session,
    knowledge: Knowledge,
    editor_id: int,
    change_description: Optional[str] = None
) -> KnowledgeVersion:
    """创建知识条目的新版本"""
    # 获取标签快照
    tags_query = db.query(
        knowledge_tag.c.tag_id,
        "tag.name",
        "tag.color"
    ).join(
        "tag",
        knowledge_tag.c.tag_id == "tag.id"
    ).filter(
        knowledge_tag.c.knowledge_id == knowledge.id
    ).all()
    
    tags_snapshot = [
        {"id": tag[0], "name": tag[1], "color": tag[2]}
        for tag in tags_query
    ]
    
    # 创建版本记录
    version = KnowledgeVersion(
        knowledge_id=knowledge.id,
        editor_id=editor_id,
        version_number=knowledge.current_version,
        title=knowledge.title,
        content=knowledge.content,
        summary=knowledge.summary,
        status=knowledge.status,
        change_description=change_description,
        tags_snapshot=tags_snapshot
    )
    
    db.add(version)
    
    # 更新当前版本号
    knowledge.current_version += 1
    
    db.commit()
    db.refresh(version)
    
    return version

def get_versions(
    db: Session,
    knowledge_id: int,
    skip: int = 0,
    limit: int = 100
) -> List[KnowledgeVersion]:
    """获取知识条目的版本历史"""
    return db.query(KnowledgeVersion).filter(
        KnowledgeVersion.knowledge_id == knowledge_id
    ).order_by(
        KnowledgeVersion.version_number.desc()
    ).offset(skip).limit(limit).all()

def get_version(
    db: Session,
    version_id: int
) -> Optional[KnowledgeVersion]:
    """获取特定版本"""
    return db.query(KnowledgeVersion).filter(
        KnowledgeVersion.id == version_id
    ).first()

def restore_version(
    db: Session,
    knowledge: Knowledge,
    version: KnowledgeVersion,
    editor_id: int
) -> Knowledge:
    """恢复到特定版本"""
    # 先创建当前版本的记录
    create_version(
        db, 
        knowledge, 
        editor_id, 
        f"系统自动保存：在恢复到版本 {version.version_number} 之前的状态"
    )
    
    # 更新知识条目为历史版本的内容
    knowledge.title = version.title
    knowledge.content = version.content
    knowledge.summary = version.summary
    knowledge.status = version.status
    knowledge.last_editor_id = editor_id
    
    # 如果需要恢复标签，需要额外处理
    # 这里简单演示，实际可能需要更复杂的标签恢复逻辑
    
    db.commit()
    db.refresh(knowledge)
    
    # 记录恢复操作
    create_version(
        db,
        knowledge,
        editor_id,
        f"恢复到版本 {version.version_number}"
    )
    
    return knowledge
```

添加版本控制API：

```python:backend/app/api/api_v1/endpoints/versions.py
from typing import Any, List, Dict

from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps
from app.services.version_service import get_versions, get_version, restore_version
from app.services.knowledge_vectorize import vectorize_knowledge

router = APIRouter()

@router.get("/{knowledge_id}", response_model=List[schemas.KnowledgeVersion])
def read_knowledge_versions(
    *,
    db: Session = Depends(deps.get_db),
    knowledge_id: int,
    skip: int = 0,
    limit: int = 20,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取知识条目的版本历史。
    """
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此知识条目的版本历史")
    
    # 获取版本历史
    versions = get_versions(db, knowledge_id, skip, limit)
    return versions

@router.get("/detail/{version_id}", response_model=schemas.KnowledgeVersion)
def read_version_detail(
    *,
    db: Session = Depends(deps.get_db),
    version_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取特定版本的详情。
    """
    # 获取版本
    version = get_version(db, version_id)
    if not version:
        raise HTTPException(status_code=404, detail="版本不存在")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=version.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此版本")
    
    return version

@router.post("/{version_id}/restore", response_model=schemas.Knowledge)
def restore_to_version(
    *,
    db: Session = Depends(deps.get_db),
    version_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    恢复到特定版本。
    """
    # 获取版本
    version = get_version(db, version_id)
    if not version:
        raise HTTPException(status_code=404, detail="版本不存在")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=version.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权恢复此版本")
    
    # 恢复版本
    restored_knowledge = restore_version(db, knowledge, version, current_user.id)
    
    # 如果是已发布状态，更新向量
    if restored_knowledge.status == "published":
        vectorize_knowledge(restored_knowledge.id, db)
    
    return restored_knowledge

@router.post("/{knowledge_id}/compare", response_model=Dict[str, Any])
def compare_versions(
    *,
    db: Session = Depends(deps.get_db),
    knowledge_id: int,
    version_ids: List[int] = Body(...),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    比较两个版本的差异。
    """
    if len(version_ids) != 2:
        raise HTTPException(status_code=400, detail="必须提供两个版本ID进行比较")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权比较此知识条目的版本")
    
    # 获取两个版本
    version1 = get_version(db, version_ids[0])
    version2 = get_version(db, version_ids[1])
    
    if not version1 or not version2:
        raise HTTPException(status_code=404, detail="版本不存在")
    
    if version1.knowledge_id != knowledge_id or version2.knowledge_id != knowledge_id:
        raise HTTPException(status_code=400, detail="版本不属于指定的知识条目")
    
    # 简单比较（实际可能需要更复杂的差异比较算法）
    comparison = {
        "title": {
            "old": version1.title,
            "new": version2.title,
            "changed": version1.title != version2.title
        },
        "content": {
            "old": version1.content,
            "new": version2.content,
            "changed": version1.content != version2.content
        },
        "summary": {
            "old": version1.summary,
            "new": version2.summary,
            "changed": version1.summary != version2.summary
        },
        "status": {
            "old": version1.status,
            "new": version2.status,
            "changed": version1.status != version2.status
        },
        "tags": {
            "old": version1.tags_snapshot,
            "new": version2.tags_snapshot,
            "changed": version1.tags_snapshot != version2.tags_snapshot
        }
    }
    
    return {
        "version1": {
            "id": version1.id,
            "version_number": version1.version_number,
            "editor": version1.editor.username if version1.editor else None,
            "created_at": version1.created_at
        },
        "version2": {
            "id": version2.id,
            "version_number": version2.version_number,
            "editor": version2.editor.username if version2.editor else None,
            "created_at": version2.created_at
        },
        "comparison": comparison
    }
```

### 2. 知识审核与发布流程

首先添加审核模型:

```python:backend/app/models/review.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base_class import Base

class ReviewRequest(Base):
    """知识审核请求"""
    id = Column(Integer, primary_key=True, index=True)
    status = Column(String(20), default="pending")  # pending, approved, rejected
    comment = Column(Text, nullable=True)
    
    # 关系
    knowledge_id = Column(Integer, ForeignKey("knowledge.id"), nullable=False)
    knowledge = relationship("Knowledge")
    
    submitter_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    submitter = relationship("User", foreign_keys=[submitter_id])
    
    reviewer_id = Column(Integer, ForeignKey("user.id"), nullable=True)
    reviewer = relationship("User", foreign_keys=[reviewer_id])
    
    # 时间戳
    submitted_at = Column(DateTime(timezone=True), server_default=func.now())
    reviewed_at = Column(DateTime(timezone=True), nullable=True)
```

添加审核Schema:

```python:backend/app/schemas/review.py
from typing import Optional, Dict, Any
from datetime import datetime
from pydantic import BaseModel

class ReviewRequestBase(BaseModel):
    knowledge_id: int
    comment: Optional[str] = None

class ReviewRequestCreate(ReviewRequestBase):
    pass

class ReviewAction(BaseModel):
    status: str  # approved, rejected
    comment: Optional[str] = None

class ReviewRequestInDBBase(ReviewRequestBase):
    id: int
    status: str
    submitter_id: int
    reviewer_id: Optional[int] = None
    submitted_at: datetime
    reviewed_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class ReviewRequest(ReviewRequestInDBBase):
    submitter: Dict[str, Any]
    reviewer: Optional[Dict[str, Any]] = None
    knowledge: Dict[str, Any]
```

添加审核服务:

```python:backend/app/services/review_service.py
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from datetime import datetime
import json

from app.models.knowledge import Knowledge
from app.models.review import ReviewRequest
from app.services.version_service import create_version
from app.services.knowledge_vectorize import vectorize_knowledge, delete_knowledge_vector

def submit_for_review(
    db: Session,
    knowledge_id: int,
    submitter_id: int,
    comment: Optional[str] = None
) -> ReviewRequest:
    """提交知识条目进行审核"""
    # 检查是否已有未完成的审核请求
    existing_request = db.query(ReviewRequest).filter(
        ReviewRequest.knowledge_id == knowledge_id,
        ReviewRequest.status == "pending"
    ).first()
    
    if existing_request:
        return existing_request
    
    # 创建审核请求
    review_request = ReviewRequest(
        knowledge_id=knowledge_id,
        submitter_id=submitter_id,
        comment=comment,
        status="pending"
    )
    
    db.add(review_request)
    db.commit()
    db.refresh(review_request)
    
    return review_request

def approve_review(
    db: Session,
    request_id: int,
    reviewer_id: int,
    comment: Optional[str] = None
) -> ReviewRequest:
    """批准审核请求"""
    request = db.query(ReviewRequest).filter(ReviewRequest.id == request_id).first()
    if not request:
        return None
    
    # 更新审核请求
    request.status = "approved"
    request.reviewer_id = reviewer_id
    request.comment = comment
    request.reviewed_at = datetime.now()
    
    # 获取知识条目
    knowledge = db.query(Knowledge).filter(Knowledge.id == request.knowledge_id).first()
    if knowledge:
        # 创建当前版本的记录
        create_version(
            db,
            knowledge,
            reviewer_id,
            f"审核批准发布"
        )
        
        # 更新状态为已发布
        knowledge.status = "published"
        
        # 更新向量
        vectorize_knowledge(knowledge.id, db)
    
    db.commit()
    db.refresh(request)
    
    return request

def reject_review(
    db: Session,
    request_id: int,
    reviewer_id: int,
    comment: Optional[str] = None
) -> ReviewRequest:
    """拒绝审核请求"""
    request = db.query(ReviewRequest).filter(ReviewRequest.id == request_id).first()
    if not request:
        return None
    
    # 更新审核请求
    request.status = "rejected"
    request.reviewer_id = reviewer_id
    request.comment = comment

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统优化功能

## 三、知识管理功能扩展(续)

### 2. 知识审核与发布流程(续)

```python:backend/app/services/review_service.py
def reject_review(
    db: Session,
    request_id: int,
    reviewer_id: int,
    comment: Optional[str] = None
) -> ReviewRequest:
    """拒绝审核请求"""
    request = db.query(ReviewRequest).filter(ReviewRequest.id == request_id).first()
    if not request:
        return None
    
    # 更新审核请求
    request.status = "rejected"
    request.reviewer_id = reviewer_id
    request.comment = comment
    request.reviewed_at = datetime.now()
    
    # 获取知识条目
    knowledge = db.query(Knowledge).filter(Knowledge.id == request.knowledge_id).first()
    if knowledge:
        # 创建当前版本的记录
        create_version(
            db,
            knowledge,
            reviewer_id,
            f"审核拒绝: {comment}"
        )
    
    db.commit()
    db.refresh(request)
    
    return request

def get_review_requests(
    db: Session,
    organization_id: Optional[int] = None,
    status: Optional[str] = None,
    submitter_id: Optional[int] = None,
    reviewer_id: Optional[int] = None,
    skip: int = 0,
    limit: int = 100
) -> List[ReviewRequest]:
    """获取审核请求列表"""
    query = db.query(ReviewRequest)
    
    # 过滤条件
    if organization_id:
        query = query.join(Knowledge).filter(Knowledge.organization_id == organization_id)
    
    if status:
        query = query.filter(ReviewRequest.status == status)
    
    if submitter_id:
        query = query.filter(ReviewRequest.submitter_id == submitter_id)
    
    if reviewer_id:
        query = query.filter(ReviewRequest.reviewer_id == reviewer_id)
    
    # 排序和分页
    return query.order_by(ReviewRequest.submitted_at.desc()).offset(skip).limit(limit).all()

def get_review_request(db: Session, request_id: int) -> Optional[ReviewRequest]:
    """获取特定审核请求"""
    return db.query(ReviewRequest).filter(ReviewRequest.id == request_id).first()
```

添加审核API:

```python:backend/app/api/api_v1/endpoints/reviews.py
from typing import Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api import deps
from app.services.review_service import (
    submit_for_review, approve_review, reject_review,
    get_review_requests, get_review_request
)

router = APIRouter()

@router.post("/submit", response_model=schemas.ReviewRequest)
def create_review_request(
    *,
    db: Session = Depends(deps.get_db),
    review_in: schemas.ReviewRequestCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    提交知识条目进行审核。
    """
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=review_in.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id:
        raise HTTPException(status_code=403, detail="无权提交此知识条目进行审核")
    
    # 检查知识条目状态
    if knowledge.status == "published":
        raise HTTPException(status_code=400, detail="已发布的知识条目不需要审核")
    
    # 提交审核
    review_request = submit_for_review(
        db=db,
        knowledge_id=review_in.knowledge_id,
        submitter_id=current_user.id,
        comment=review_in.comment
    )
    
    return review_request

@router.post("/{request_id}/approve", response_model=schemas.ReviewRequest)
def approve_review_request(
    *,
    db: Session = Depends(deps.get_db),
    request_id: int,
    action: schemas.ReviewAction,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    批准审核请求。
    """
    # 检查审核请求是否存在
    review_request = get_review_request(db=db, request_id=request_id)
    if not review_request:
        raise HTTPException(status_code=404, detail="审核请求不存在")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=review_request.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限（管理员或同组织的用户）
    if not current_user.is_admin and knowledge.organization_id != current_user.organization_id:
        raise HTTPException(status_code=403, detail="无权审核此请求")
    
    # 检查请求状态
    if review_request.status != "pending":
        raise HTTPException(status_code=400, detail=f"此请求已经被{review_request.status}")
    
    # 不能自己审核自己的请求
    if review_request.submitter_id == current_user.id:
        raise HTTPException(status_code=400, detail="不能审核自己提交的请求")
    
    # 批准请求
    updated_request = approve_review(
        db=db,
        request_id=request_id,
        reviewer_id=current_user.id,
        comment=action.comment
    )
    
    return updated_request

@router.post("/{request_id}/reject", response_model=schemas.ReviewRequest)
def reject_review_request(
    *,
    db: Session = Depends(deps.get_db),
    request_id: int,
    action: schemas.ReviewAction,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    拒绝审核请求。
    """
    # 检查审核请求是否存在
    review_request = get_review_request(db=db, request_id=request_id)
    if not review_request:
        raise HTTPException(status_code=404, detail="审核请求不存在")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=review_request.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限（管理员或同组织的用户）
    if not current_user.is_admin and knowledge.organization_id != current_user.organization_id:
        raise HTTPException(status_code=403, detail="无权审核此请求")
    
    # 检查请求状态
    if review_request.status != "pending":
        raise HTTPException(status_code=400, detail=f"此请求已经被{review_request.status}")
    
    # 不能自己审核自己的请求
    if review_request.submitter_id == current_user.id:
        raise HTTPException(status_code=400, detail="不能审核自己提交的请求")
    
    # 拒绝必须提供理由
    if not action.comment:
        raise HTTPException(status_code=400, detail="拒绝请求必须提供理由")
    
    # 拒绝请求
    updated_request = reject_review(
        db=db,
        request_id=request_id,
        reviewer_id=current_user.id,
        comment=action.comment
    )
    
    return updated_request

@router.get("/", response_model=List[schemas.ReviewRequest])
def read_review_requests(
    *,
    db: Session = Depends(deps.get_db),
    status: Optional[str] = None,
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取审核请求列表。
    """
    # 管理员可以查看所有审核请求
    if current_user.is_admin:
        requests = get_review_requests(
            db=db,
            status=status,
            skip=skip,
            limit=limit
        )
    else:
        # 普通用户只能查看其组织内的审核请求
        requests = get_review_requests(
            db=db,
            organization_id=current_user.organization_id,
            status=status,
            skip=skip,
            limit=limit
        )
    
    return requests

@router.get("/submitted", response_model=List[schemas.ReviewRequest])
def read_submitted_reviews(
    *,
    db: Session = Depends(deps.get_db),
    status: Optional[str] = None,
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取当前用户提交的审核请求。
    """
    requests = get_review_requests(
        db=db,
        submitter_id=current_user.id,
        status=status,
        skip=skip,
        limit=limit
    )
    
    return requests

@router.get("/reviewed", response_model=List[schemas.ReviewRequest])
def read_reviewed_requests(
    *,
    db: Session = Depends(deps.get_db),
    status: Optional[str] = None,
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取当前用户审核过的请求。
    """
    requests = get_review_requests(
        db=db,
        reviewer_id=current_user.id,
        status=status,
        skip=skip,
        limit=limit
    )
    
    return requests

@router.get("/{request_id}", response_model=schemas.ReviewRequest)
def read_review_request(
    *,
    db: Session = Depends(deps.get_db),
    request_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取特定审核请求的详情。
    """
    request = get_review_request(db=db, request_id=request_id)
    if not request:
        raise HTTPException(status_code=404, detail="审核请求不存在")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=request.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if (not current_user.is_admin and 
        knowledge.organization_id != current_user.organization_id and
        request.submitter_id != current_user.id and
        request.reviewer_id != current_user.id):
        raise HTTPException(status_code=403, detail="无权查看此审核请求")
    
    return request
```

### 3. 协作编辑功能

添加协作相关模型：

```python:backend/app/models/collaboration.py
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base_class import Base

class CollaborationSession(Base):
    """协作编辑会话"""
    id = Column(Integer, primary_key=True, index=True)
    status = Column(String(20), default="active")  # active, closed
    
    # 关系
    knowledge_id = Column(Integer, ForeignKey("knowledge.id"), nullable=False)
    knowledge = relationship("Knowledge")
    
    creator_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    creator = relationship("User", foreign_keys=[creator_id])
    
    # 当前编辑者
    current_editor_id = Column(Integer, ForeignKey("user.id"), nullable=True)
    current_editor = relationship("User", foreign_keys=[current_editor_id])
    
    # 协作者
    collaborators = relationship("CollaborationMember", back_populates="session")
    
    # 当前锁定状态
    lock_expires_at = Column(DateTime(timezone=True), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class CollaborationMember(Base):
    """协作会话成员"""
    id = Column(Integer, primary_key=True, index=True)
    
    # 关系
    session_id = Column(Integer, ForeignKey("collaboration_session.id"), nullable=False)
    session = relationship("CollaborationSession", back_populates="collaborators")
    
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    user = relationship("User")
    
    # 权限
    can_edit = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    
    joined_at = Column(DateTime(timezone=True), server_default=func.now())
    last_active_at = Column(DateTime(timezone=True), nullable=True)

class CollaborationEvent(Base):
    """协作编辑事件"""
    id = Column(Integer, primary_key=True, index=True)
    event_type = Column(String(50), nullable=False)  # edit, comment, join, leave
    content = Column(Text, nullable=True)
    metadata = Column(JSON, nullable=True)
    
    # 关系
    session_id = Column(Integer, ForeignKey("collaboration_session.id"), nullable=False)
    session = relationship("CollaborationSession")
    
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    user = relationship("User")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class CollaborationComment(Base):
    """协作编辑评论"""
    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text, nullable=False)
    resolved = Column(Boolean, default=False)
    
    # 关系
    session_id = Column(Integer, ForeignKey("collaboration_session.id"), nullable=False)
    session = relationship("CollaborationSession")
    
    user_id = Column(Integer, ForeignKey("user.id"), nullable=False)
    user = relationship("User")
    
    # 对于回复
    parent_id = Column(Integer, ForeignKey("collaboration_comment.id"), nullable=True)
    replies = relationship("CollaborationComment", backref="parent", remote_side=[id])
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

添加协作Schema：

```python:backend/app/schemas/collaboration.py
from typing import Optional, List, Dict, Any
from datetime import datetime
from pydantic import BaseModel

# 协作会话
class CollaborationSessionBase(BaseModel):
    knowledge_id: int
    status: str = "active"

class CollaborationSessionCreate(CollaborationSessionBase):
    pass

class CollaborationSessionUpdate(BaseModel):
    status: Optional[str] = None
    current_editor_id: Optional[int] = None
    lock_expires_at: Optional[datetime] = None

class CollaborationSessionInDBBase(CollaborationSessionBase):
    id: int
    creator_id: int
    current_editor_id: Optional[int] = None
    lock_expires_at: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class CollaborationSession(CollaborationSessionInDBBase):
    creator: Dict[str, Any]
    current_editor: Optional[Dict[str, Any]] = None
    knowledge: Dict[str, Any]

# 协作成员
class CollaborationMemberBase(BaseModel):
    session_id: int
    user_id: int
    can_edit: bool = True
    is_admin: bool = False

class CollaborationMemberCreate(CollaborationMemberBase):
    pass

class CollaborationMemberUpdate(BaseModel):
    can_edit: Optional[bool] = None
    is_admin: Optional[bool] = None

class CollaborationMemberInDBBase(CollaborationMemberBase):
    id: int
    joined_at: datetime
    last_active_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class CollaborationMember(CollaborationMemberInDBBase):
    user: Dict[str, Any]

# 协作事件
class CollaborationEventBase(BaseModel):
    session_id: int
    event_type: str
    content: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class CollaborationEventCreate(CollaborationEventBase):
    pass

class CollaborationEventInDBBase(CollaborationEventBase):
    id: int
    user_id: int
    created_at: datetime

    class Config:
        orm_mode = True

class CollaborationEvent(CollaborationEventInDBBase):
    user: Dict[str, Any]

# 协作评论
class CollaborationCommentBase(BaseModel):
    session_id: int
    content: str
    parent_id: Optional[int] = None

class CollaborationCommentCreate(CollaborationCommentBase):
    pass

class CollaborationCommentUpdate(BaseModel):
    content: Optional[str] = None
    resolved: Optional[bool] = None

class CollaborationCommentInDBBase(CollaborationCommentBase):
    id: int
    user_id: int
    resolved: bool
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True

class CollaborationComment(CollaborationCommentInDBBase):
    user: Dict[str, Any]
    replies: Optional[List['CollaborationComment']] = []
```

添加协作服务：

```python:backend/app/services/collaboration_service.py
from typing import List, Dict, Any, Optional, Tuple
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
import json

from app.models.collaboration import (
    CollaborationSession, CollaborationMember,
    CollaborationEvent, CollaborationComment
)
from app.models.knowledge import Knowledge
from app.models.user import User

def create_collaboration_session(
    db: Session,
    knowledge_id: int,
    creator_id: int
) -> CollaborationSession:
    """创建协作编辑会话"""
    # 检查是否已有活跃会话
    existing_session = db.query(CollaborationSession).filter(
        CollaborationSession.knowledge_id == knowledge_id,
        CollaborationSession.status == "active"
    ).first()
    
    if existing_session:
        # 添加创建者为会话成员
        add_session_member(db, existing_session.id, creator_id, is_admin=True)
        return existing_session
    
    # 创建新会话
    session = CollaborationSession(
        knowledge_id=knowledge_id,
        creator_id=creator_id,
        status="active"
    )
    
    db.add(session)
    db.flush()
    
    # 添加创建者为会话成员和管理员
    add_session_member(db, session.id, creator_id, is_admin=True)
    
    # 记录创建事件
    add_collaboration_event(
        db, 
        session_id=session.id, 
        user_id=creator_id, 
        event_type="create", 
        content="创建了协作会话"
    )
    
    db.commit()
    db.refresh(session)
    
    return session

def add_session_member(
    db: Session,
    session_id: int,
    user_id: int,
    can_edit: bool = True,
    is_admin: bool = False
) -> Optional[CollaborationMember]:
    """添加协作会话成员"""
    # 检查用户是否已是成员
    member = db.query(CollaborationMember).filter(
        CollaborationMember.session_id == session_id,
        CollaborationMember.user_id == user_id
    ).first()
    
    if member:
        # 更新权限
        member.can_edit = can_edit
        member.is_admin = is_admin
        member.last_active_at = datetime.now()
    else:
        # 创建新成员
        member = CollaborationMember(
            session_id=session_id,
            user_id=user_id,
            can_edit=can_edit,
            is_admin=is_admin,
            last_active_at=datetime.now()
        )
        db.add(member)
        
        # 记录加入事件
        add_collaboration_event(
            db, 
            session_id=session_id, 
            user_id=user_id, 
            event_type="join", 
            content="加入了协作会话"
        )
    
    db.commit()
    db.refresh(member)
    
    return member

def remove_session_member(
    db: Session,
    session_id: int,
    user_id: int
) -> bool:
    """移除协作会话成员"""
    member = db.query(CollaborationMember).filter(
        CollaborationMember.session_id == session_id,
        CollaborationMember.user_id == user_id
    ).first()
    
    if not member:
        return False
    
    # 记录离开事件
    add_collaboration_event(
        db, 
        session_id=session_id, 
        user_id=user_id, 
        event_type="leave", 
        content="离开了协作会话"
    )
    
    # 移除成员
    db.delete(member)
    db.commit()
    
    return True

def get_session_members(
    db: Session,
    session_id: int
) -> List[CollaborationMember]:
    """获取协作会话成员列表"""
    return db.query(CollaborationMember).filter(
        CollaborationMember.session_id == session_id
    ).all()

def acquire_edit_lock(
    db: Session,
    session_id: int,
    user_id: int,
    lock_duration_minutes: int = 5
) -> Tuple[bool, Optional[str]]:
    """
    获取编辑锁
    返回: (成功标志, 错误信息)
    """
    session = db.query(CollaborationSession).filter(
        CollaborationSession.id == session_id
    ).first()
    
    if not session:
        return False, "会话不存在"
    
    if session.status != "active":
        return False, "会话已关闭"
    
    # 检查用户是否为会话成员
    member = db.query(CollaborationMember).filter(
        CollaborationMember.session_id == session_id,
        CollaborationMember.user_id == user_id
    ).first()
    
    if not member:
        return False, "用户不是会话成员"
    
    if not member.can_edit:
        return False, "用户无编辑权限"
    
    # 检查当前锁状态
    now = datetime.now()
    if session.current_editor_id and session.lock_expires_at:
        # 锁还未过期且不是当前用户
        if session.lock_expires_at > now and session.current_editor_id != user_id:
            editor = db.query(User).filter(User.id == session.current_editor_id).first()
            editor_name = editor.username if editor else "未知用户"
            return False, f"文档正被 {editor_name} 编辑，请稍后再试"
    
    # 获取或更新锁
    session.current_editor_id = user_id
    session.lock_expires_at = now + timedelta(minutes=lock_duration_minutes)
    
    # 更新成员最后活动时间
    member.last_active_at = now
    
    db.commit()
    
    return True, None

def release_edit_lock(
    db: Session,
    session_id: int,
    user_id: int
) -> bool:
    """释放编辑锁"""
    session = db.query(CollaborationSession).filter(
        CollaborationSession.id == session_id
    ).first()
    
    if not session:
        return False
    
    # 只有锁的拥有者或管理员可以释放锁
    if session.current_editor_id == user_id:
        session.current_editor_id = None
        session.lock_expires_at = None
        db.commit()
        return True
    else:
        # 检查是否为管理员
        is_admin = db.query(CollaborationMember).filter(
            CollaborationMember.session_id == session_id,
            CollaborationMember.user_id == user_id,
            CollaborationMember.is_admin == True
        ).first() is not None
        
        if is_admin:
            session.current_editor_id = None
            session.lock_expires_at = None
            db.commit()
            return True
    
    return False

def add_collaboration_event(
    db: Session,
    session_id: int,
    user_id: int,
    event_type: str,
    content: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> CollaborationEvent:
    """添加协作事件"""
    event = CollaborationEvent(
        session_id=session_id,
        user_id=user_id,
        event_type=event_type,
        content=content,
        metadata=metadata
    )
    
    db.add(event)
    db.commit()
    db.refresh(event)
    
    return event

def get_collaboration_events(
    db: Session,
    session_id: int,
    skip: int = 0,
    limit: int = 100
) -> List[CollaborationEvent]:
    """获取协作事件列表"""
    return db.query(CollaborationEvent).filter(
        CollaborationEvent.session_id == session_id
    ).order_by(
        CollaborationEvent.created_at.desc()
    ).offset(skip).limit(limit).all()

def add_collaboration_comment(
    db: Session,
    session_id: int,
    user_id: int,
    content: str,
    parent_id: Optional[int] = None
) -> CollaborationComment:
    """添加协作评论"""
    comment = CollaborationComment(
        session_id=session_id,
        user_id=user_id,
        content=content,
        parent_id=parent_id,
        resolved=False
    )
    
    db.add(comment)
    
    # 记录评论事件
    add_collaboration_event(
        db, 
        session_id=session_id, 
        user_id=user_id, 
        event_type="comment", 
        content=content[:50] + ("..." if len(content) > 50 else "")
    )
    
    db.commit()
    db.refresh(comment)
    
    return comment

def get_collaboration_comments(
    db: Session,
    session_id: int,
    parent_id: Optional[int] = None,
    include_resolved: bool = False,
    skip: int = 0,
    limit: int = 100
) -> List[CollaborationComment]:
    """获取协作评论列表"""
    query = db.query(CollaborationComment).filter(
        CollaborationComment.session_id == session_id,
        CollaborationComment.parent_id == parent_id
    )
    
    if not include_resolved:
        query = query.filter(CollaborationComment.resolved == False)
    
    return query.order_by(
        CollaborationComment.created_at.desc()
    ).offset(skip).limit(limit).all()

def close_collaboration_session(
    db: Session,
    session_id: int,
    user_id: int
) -> Optional[CollaborationSession]:
    """关闭协作会话"""
    session = db.query(CollaborationSession).filter(
        CollaborationSession.id == session_id
    ).first()
    
    if not session:
        return None
    
    # 检查是否为创建者或管理员
    is_creator = session.creator_id == user_id
    is_admin = db.query(CollaborationMember).filter(
        CollaborationMember.session_id == session_id,
        CollaborationMember.user_id == user_id,
        CollaborationMember.is_admin == True
    ).first() is not None
    
    if not (is_creator or is_admin):
        return None
    
    # 关闭会话
    session.status = "closed"
    session.current_editor_id = None
    session.lock_expires_at = None
    
    # 记录关闭事件
    add_collaboration_event(
        db, 
        session_id=session_id, 
        user_id=user_id, 
        event_type="close", 
        content="关闭了协作会话"
    )
    
    db.commit()
    db.refresh(session)
    
    return session
```

添加协作API:

```python:backend/app/api/api_v1/endpoints/collaboration.py
from typing import Any, List, Optional, Dict

from fastapi import APIRouter, Depends, HTTPException, Query, WebSocket, WebSocketDisconnect
from sqlalchemy.orm import Session
from datetime import datetime

from app import crud, models, schemas
from app.api import deps
from app.services.collaboration_service import (
    create_collaboration_session, add_session_member, remove_session_member,
    get_session_members, acquire_edit_lock, release_edit_lock,
    add_collaboration_event, get_collaboration_events,
    add_collaboration_comment, get_collaboration_comments,
    close_collaboration_session
)

router = APIRouter()

@router.post("/sessions", response_model=schemas.CollaborationSession)
def create_session(
    *,
    db: Session = Depends(deps.get_db),
    session_in: schemas.CollaborationSessionCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建协作编辑会话。
    """
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=session_in.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id:
        raise HTTPException(status_code=403, detail="无权为此知识条目创建协作会话")
    
    # 创建会话
    session = create_collaboration_session(
        db=db,
        knowledge_id=session_in.knowledge_id,
        creator_id=current_user.id
    )
    
    return session

@router.get("/sessions/{session_id}", response_model=schemas.CollaborationSession)
def read_session(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取协作会话详情。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=session.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id:
        raise HTTPException(status_code=403, detail="无权访问此协作会话")
    
    return session

@router.post("/sessions/{session_id}/join", response_model=schemas.CollaborationMember)
def join_session(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    加入协作会话。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查会话状态
    if session.status != "active":
        raise HTTPException(status_code=400, detail="会话已关闭")
    
    # 检查知识条目是否存在
    knowledge = crud.knowledge.get(db=db, id=session.knowledge_id)
    if not knowledge:
        raise HTTPException(status_code=404, detail="知识条目不存在")
    
    # 检查权限
    if knowledge.organization_id != current_user.organization_id:
        raise HTTPException(status_code=403, detail="无权加入此协作会话")
    
    # 加入会话
    member = add_session_member(
        db=db,
        session_id=session_id,
        user_id=current_user.id
    )
    
    return member

@router.post("/sessions/{session_id}/leave", response_model=Dict[str, Any])
def leave_session(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    离开协作会话。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first()
    
    if not member:
        raise HTTPException(status_code=400, detail="您不是此会话的成员")
    
    # 如果是唯一管理员，不允许离开
    if member.is_admin:
        admin_count = db.query(models.CollaborationMember).filter(
            models.CollaborationMember.session_id == session_id,
            models.CollaborationMember.is_admin == True
        ).count()
        
        if admin_count == 1:
            raise HTTPException(status_code=400, detail="您是唯一的管理员，无法离开会话")
    
    # 如果当前正在编辑，释放锁
    if session.current_editor_id == current_user.id:
        release_edit_lock(db, session_id, current_user.id)
    
    # 离开会话
    success = remove_session_member(
        db=db,
        session_id=session_id,
        user_id=current_user.id
    )
    
    return {"success": success}

@router.get("/sessions/{session_id}/members", response_model=List[schemas.CollaborationMember])
def read_session_members(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取协作会话成员列表。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    is_member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first() is not None
    
    if

---

_**User**_

继续

---

_**Assistant**_



---

# 继续完成系统优化功能

## 三、知识管理功能扩展(续)

### 3. 协作编辑功能(续)

```python:backend/app/api/api_v1/endpoints/collaboration.py
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    is_member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first() is not None
    
    if not is_member and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权查看此会话成员")
    
    # 获取成员列表
    members = get_session_members(db=db, session_id=session_id)
    return members

@router.post("/sessions/{session_id}/lock", response_model=Dict[str, Any])
def acquire_lock(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取编辑锁。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 尝试获取锁
    success, message = acquire_edit_lock(
        db=db,
        session_id=session_id,
        user_id=current_user.id
    )
    
    if not success:
        raise HTTPException(status_code=400, detail=message)
    
    return {
        "success": True,
        "message": "已获取编辑锁",
        "expires_at": session.lock_expires_at
    }

@router.post("/sessions/{session_id}/unlock", response_model=Dict[str, Any])
def release_lock(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    释放编辑锁。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 尝试释放锁
    success = release_edit_lock(
        db=db,
        session_id=session_id,
        user_id=current_user.id
    )
    
    if not success:
        raise HTTPException(status_code=400, detail="无权释放锁")
    
    return {"success": True, "message": "已释放编辑锁"}

@router.post("/sessions/{session_id}/events", response_model=schemas.CollaborationEvent)
def create_event(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    event_in: schemas.CollaborationEventCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    创建协作事件。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    is_member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first() is not None
    
    if not is_member:
        raise HTTPException(status_code=403, detail="不是会话成员，无法创建事件")
    
    # 创建事件
    event = add_collaboration_event(
        db=db,
        session_id=session_id,
        user_id=current_user.id,
        event_type=event_in.event_type,
        content=event_in.content,
        metadata=event_in.metadata
    )
    
    return event

@router.get("/sessions/{session_id}/events", response_model=List[schemas.CollaborationEvent])
def read_events(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取协作事件列表。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    is_member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first() is not None
    
    if not is_member and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权查看此会话事件")
    
    # 获取事件列表
    events = get_collaboration_events(
        db=db,
        session_id=session_id,
        skip=skip,
        limit=limit
    )
    
    return events

@router.post("/sessions/{session_id}/comments", response_model=schemas.CollaborationComment)
def create_comment(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    comment_in: schemas.CollaborationCommentCreate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    添加协作评论。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    is_member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first() is not None
    
    if not is_member:
        raise HTTPException(status_code=403, detail="不是会话成员，无法添加评论")
    
    # 检查父评论
    if comment_in.parent_id:
        parent_comment = db.query(models.CollaborationComment).filter(
            models.CollaborationComment.id == comment_in.parent_id
        ).first()
        
        if not parent_comment:
            raise HTTPException(status_code=404, detail="父评论不存在")
        
        if parent_comment.session_id != session_id:
            raise HTTPException(status_code=400, detail="父评论不属于此会话")
    
    # 添加评论
    comment = add_collaboration_comment(
        db=db,
        session_id=session_id,
        user_id=current_user.id,
        content=comment_in.content,
        parent_id=comment_in.parent_id
    )
    
    return comment

@router.get("/sessions/{session_id}/comments", response_model=List[schemas.CollaborationComment])
def read_comments(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    parent_id: Optional[int] = None,
    include_resolved: bool = False,
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    获取协作评论列表。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 检查是否为会话成员
    is_member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == current_user.id
    ).first() is not None
    
    if not is_member and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权查看此会话评论")
    
    # 获取评论列表
    comments = get_collaboration_comments(
        db=db,
        session_id=session_id,
        parent_id=parent_id,
        include_resolved=include_resolved,
        skip=skip,
        limit=limit
    )
    
    return comments

@router.put("/comments/{comment_id}", response_model=schemas.CollaborationComment)
def update_comment(
    *,
    db: Session = Depends(deps.get_db),
    comment_id: int,
    comment_in: schemas.CollaborationCommentUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    更新协作评论。
    """
    comment = db.query(models.CollaborationComment).filter(
        models.CollaborationComment.id == comment_id
    ).first()
    
    if not comment:
        raise HTTPException(status_code=404, detail="评论不存在")
    
    # 检查是否为评论作者或会话管理员
    is_author = comment.user_id == current_user.id
    is_admin = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == comment.session_id,
        models.CollaborationMember.user_id == current_user.id,
        models.CollaborationMember.is_admin == True
    ).first() is not None
    
    if not (is_author or is_admin):
        raise HTTPException(status_code=403, detail="无权更新此评论")
    
    # 更新评论
    update_data = comment_in.dict(exclude_unset=True)
    for key, value in update_data.items():
        setattr(comment, key, value)
    
    # 如果更新了内容，记录修改事件
    if 'content' in update_data and is_author:
        add_collaboration_event(
            db=db,
            session_id=comment.session_id,
            user_id=current_user.id,
            event_type="comment_edit",
            content=f"编辑了评论: {update_data['content'][:30]}...",
            metadata={"comment_id": comment.id}
        )
    
    # 如果更新了解决状态，记录解决事件
    if 'resolved' in update_data:
        event_type = "comment_resolve" if update_data['resolved'] else "comment_unresolve"
        add_collaboration_event(
            db=db,
            session_id=comment.session_id,
            user_id=current_user.id,
            event_type=event_type,
            content=f"{'解决' if update_data['resolved'] else '重新打开'}了评论",
            metadata={"comment_id": comment.id}
        )
    
    db.commit()
    db.refresh(comment)
    
    return comment

@router.post("/sessions/{session_id}/close", response_model=schemas.CollaborationSession)
def close_session(
    *,
    db: Session = Depends(deps.get_db),
    session_id: int,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> Any:
    """
    关闭协作会话。
    """
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="协作会话不存在")
    
    # 尝试关闭会话
    updated_session = close_collaboration_session(
        db=db,
        session_id=session_id,
        user_id=current_user.id
    )
    
    if not updated_session:
        raise HTTPException(status_code=403, detail="无权关闭此会话")
    
    return updated_session

# WebSocket连接管理
connected_clients = {}

@router.websocket("/ws/{session_id}/{user_id}")
async def websocket_collaboration(
    websocket: WebSocket,
    session_id: int,
    user_id: int,
    db: Session = Depends(deps.get_ws_db),
):
    """
    WebSocket连接用于实时协作。
    """
    await websocket.accept()
    
    # 验证会话和用户
    session = db.query(models.CollaborationSession).filter(
        models.CollaborationSession.id == session_id
    ).first()
    
    if not session or session.status != "active":
        await websocket.send_json({"type": "error", "message": "会话不存在或已关闭"})
        await websocket.close()
        return
    
    # 检查用户是否是会话成员
    member = db.query(models.CollaborationMember).filter(
        models.CollaborationMember.session_id == session_id,
        models.CollaborationMember.user_id == user_id
    ).first()
    
    if not member:
        await websocket.send_json({"type": "error", "message": "用户不是会话成员"})
        await websocket.close()
        return
    
    # 更新用户活动时间
    member.last_active_at = datetime.now()
    db.commit()
    
    # 添加到连接客户端
    if session_id not in connected_clients:
        connected_clients[session_id] = {}
    
    connected_clients[session_id][user_id] = websocket
    
    # 通知其他用户有新用户加入
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user:
        notification = {
            "type": "user_joined",
            "user_id": user_id,
            "username": user.username,
            "timestamp": datetime.now().isoformat()
        }
        
        for client_id, client_ws in connected_clients[session_id].items():
            if client_id != user_id:
                try:
                    await client_ws.send_json(notification)
                except:
                    pass
    
    try:
        # 处理消息
        while True:
            data = await websocket.receive_json()
            
            # 处理不同类型的消息
            if data.get("type") == "cursor_move":
                # 广播光标位置
                for client_id, client_ws in connected_clients[session_id].items():
                    if client_id != user_id:
                        try:
                            await client_ws.send_json({
                                "type": "cursor_move",
                                "user_id": user_id,
                                "position": data.get("position"),
                                "timestamp": datetime.now().isoformat()
                            })
                        except:
                            pass
            
            elif data.get("type") == "content_change":
                # 检查用户是否有编辑锁
                if session.current_editor_id != user_id:
                    await websocket.send_json({
                        "type": "error",
                        "message": "没有编辑锁，无法修改内容"
                    })
                    continue
                
                # 广播内容变更
                for client_id, client_ws in connected_clients[session_id].items():
                    if client_id != user_id:
                        try:
                            await client_ws.send_json({
                                "type": "content_change",
                                "user_id": user_id,
                                "changes": data.get("changes"),
                                "timestamp": datetime.now().isoformat()
                            })
                        except:
                            pass
                
                # 记录编辑事件
                add_collaboration_event(
                    db=db,
                    session_id=session_id,
                    user_id=user_id,
                    event_type="edit",
                    content="编辑了文档内容"
                )
            
            elif data.get("type") == "comment_add":
                # 创建评论
                comment = add_collaboration_comment(
                    db=db,
                    session_id=session_id,
                    user_id=user_id,
                    content=data.get("content", ""),
                    parent_id=data.get("parent_id")
                )
                
                # 广播新评论
                for client_id, client_ws in connected_clients[session_id].items():
                    try:
                        await client_ws.send_json({
                            "type": "comment_add",
                            "comment_id": comment.id,
                            "user_id": user_id,
                            "content": comment.content,
                            "parent_id": comment.parent_id,
                            "timestamp": comment.created_at.isoformat()
                        })
                    except:
                        pass
            
            elif data.get("type") == "heartbeat":
                # 更新用户活动时间
                member.last_active_at = datetime.now()
                db.commit()
                await websocket.send_json({"type": "heartbeat_ack"})
    
    except WebSocketDisconnect:
        # 用户断开连接
        if session_id in connected_clients and user_id in connected_clients[session_id]:
            del connected_clients[session_id][user_id]
            
            # 如果没有连接的客户端，释放编辑锁
            if session.current_editor_id == user_id:
                session.current_editor_id = None
                session.lock_expires_at = None
                db.commit()
            
            # 通知其他用户
            notification = {
                "type": "user_left",
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
            
            for client_ws in connected_clients[session_id].values():
                try:
                    await client_ws.send_json(notification)
                except:
                    pass
    
    except Exception as e:
        # 处理其他异常
        print(f"WebSocket错误: {str(e)}")
```

## 四、系统功能集成回顾

至此，我们已经完成了企业智能知识库平台的全面优化和功能扩展，包括：

### 1. 知识库检索优化

- 向量数据库集成，支持语义搜索
- OCR文本提取功能，支持从图片和PDF提取文本
- 知识自动分类功能

### 2. 大语言模型优化

- 多模型切换和管理功能
- 模型微调功能
- 完善的API支持和服务层设计

### 3. 知识管理功能扩展

- 版本控制与历史记录
- 知识审核与发布流程
- 协作编辑功能

这些功能的实现大大提升了系统的实用性和用户体验：

1. **智能检索能力提升**：通过向量数据库实现语义搜索，让用户能够更自然地查找知识，不再局限于关键词匹配，同时OCR功能让系统能够"理解"图片和PDF中的内容。

2. **模型能力增强**：多模型支持和微调功能让企业能够定制适合自己业务场景的大语言模型，提升问答质量和准确性。

3. **协作与治理**：版本控制、审核流程和协作编辑功能让知识的创建和维护更加规范，多用户协作更加高效，同时确保知识质量。

## 五、下一步建议

1. **前端界面优化**：为以上后端功能实现对应的前端界面，特别是协作编辑模块的实时协作功能。

2. **用户反馈系统**：实现知识反馈和评分机制，让用户能够标记有用或无用的知识，帮助系统持续提升知识质量。

3. **数据分析与报表**：实现更全面的数据统计和可视化功能，帮助管理员了解系统使用情况和知识库健康度。

4. **移动端适配**：完善移动端界面，让用户能够随时随地访问和利用企业知识库。

5. **系统集成**：与企业其他系统集成，如企业内部即时通讯工具、项目管理系统等，实现知识的无缝流通和应用。

6. **高级权限管理**：实现更细粒度的权限控制，如知识条目级别的访问权限、部门级别的知识隔离等。

通过这些持续优化，企业智能知识库平台将能够成为企业内部真正的知识中枢，不断提升员工的工作效率和企业的知识价值。

---

_**User**_

刚才的优化更新到项目了么

---

_**Assistant**_



---

# 关于系统优化的部署状态

我刚才提供的所有系统优化功能（包括知识库检索优化、大语言模型优化和协作编辑等功能）只是实现方案和代码示例，还没有实际更新到您的项目中。

这些代码需要您手动集成到项目中，并进行相应的：

1. 数据库迁移
2. 依赖包安装
3. 配置更新
4. 测试和调试

如果您希望将这些功能实际应用到项目中，您需要按照我提供的代码示例进行集成，或者告诉我您需要更具体的实施指导，我可以提供更详细的部署步骤。

您是希望我提供某个特定功能的具体部署指南，还是有其他需要进一步了解的内容？

---

_**User**_

我希望你将你的修改，逐步优化到项目代码中

---

_**Assistant**_



---

# 系统优化项目集成指南

我将逐步指导您如何将系统优化功能集成到项目中。为了确保顺利集成，我们将按照以下顺序进行：

## 第一阶段：基础配置与依赖安装

### 步骤1：更新项目依赖

首先，让我们更新后端依赖以支持新功能：

```python:backend/requirements.txt
# 已有依赖
fastapi>=0.95.0
pydantic>=1.10.7
sqlalchemy>=2.0.9
python-jose>=3.3.0
passlib>=1.7.4
bcrypt>=4.0.1
python-multipart>=0.0.6
alembic>=1.10.3
email-validator>=2.0.0
uvicorn>=0.21.1
tenacity>=8.2.2

# 新增依赖
faiss-cpu>=1.7.4  # 向量数据库支持
sentence-transformers>=2.2.2  # 文本向量化
pytesseract>=0.3.10  # OCR文本识别
pdf2image>=1.16.3  # PDF处理
pdf2docx>=0.5.6  # PDF转文档
python-docx>=0.8.11  # 文档处理
anthropic>=0.3.6  # Anthropic Claude API
websockets>=11.0.3  # 用于实时协作
python-dateutil>=2.8.2  # 日期处理
```

### 步骤2：安装系统依赖

除了Python包，还需要安装一些系统依赖：

```bash
# 安装Tesseract OCR
sudo apt-get update
sudo apt-get install -y tesseract-ocr
sudo apt-get install -y tesseract-ocr-chi-sim  # 中文支持

# 安装PDF处理相关依赖
sudo apt-get install -y poppler-utils
```

### 步骤3：更新配置文件

修改配置文件以支持新功能：

```python:backend/app/core/config.py
# ... 现有代码 ...

class Settings(BaseSettings):
    # ... 现有设置 ...
    
    # 向量数据库设置
    VECTOR_DB_PATH: str = "data/vector_db"
    VECTOR_DIMENSION: int = 768
    
    # OCR设置
    TESSERACT_CMD: str = "tesseract"  # Windows下可能需要完整路径
    
    # 大语言模型设置
    DEFAULT_LLM_MODEL: str = "gpt-3.5-turbo"
    OPENAI_API_KEY: Optional[str] = None
    ANTHROPIC_API_KEY: Optional[str] = None
    
    # 文件上传设置
    UPLOAD_DIR: str = "data/uploads"
    MAX_UPLOAD_SIZE: int = 20 * 1024 * 1024  # 20MB
    
    # 模型微调设置
    FINETUNE_DATA_DIR: str = "data/finetune"
    
    # 协作设置
    LOCK_TIMEOUT_MINUTES: int = 30  # 编辑锁超时时间
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()

# 确保必要的目录存在
os.makedirs(settings.VECTOR_DB_PATH, exist_ok=True)
os.makedirs(settings.UPLOAD_DIR, exist_ok=True)
os.makedirs(settings.FINETUNE_DATA_DIR, exist_ok=True)
```

## 第二阶段：知识库检索优化

### 步骤1：添加向量数据库服务

```python:backend/app/services/vector_db.py
import os
import numpy as np
import faiss
import pickle
from typing import

---



---

